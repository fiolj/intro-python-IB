.. _clase_14:


====================================
Clase 14: Introducción a ``pandas``
====================================

=========================

El análisis y consumo de grandes cantidades de información requiere
herramientas que permitan limpiar, filtrar, agrupar los datos. Una de
las bibliotecas fundamentales para ello es ``pandas``. ``pandas``
contiene estructuras de datos y funciones que permiten la manipulación
de los datos en forma rápida. ``pandas`` está inspirada fuertemente en
``numpy``, en el sentido en que adopta en su diseño el estilo idiomático
de ``numpy``. La diferencia principal radica en que ``numpy`` se utiliza
para conjuntos de datos homogéneos, mientras que ``pandas`` está
diseñada para trabajar con tablas o datos heterogéneos.

Otra biblioteca con características similares es
`polars <https://docs.pola.rs/>`__

Input/Output con ``pandas``
===========================

Para poder leer o escribir datos, ``pandas`` provee una serie de métodos
específicos para todos los tipos de datos estructurados usuales, ya sea
en formato texto o binario. Los métodos para leer de archivos se
reconocen por el prefijo ``.read_``, mientras que para escribir usaremos
``.to_``. Para cada formato particular de archivo, estos métodos
aceptarán un conjunto de argumentos adicionales que permiten adecuar
nuestro código.

   Si se usa VSCode, se puede instalar la extensión `Data
   Wrangler <https://marketplace.visualstudio.com/items?itemName=ms-toolsai.datawrangler>`__
   que permite inspeccionar ``DataFrames``. Puede ser útil cuando uno
   trabaja con muchos datos.

JSON
----

JSON (JavaScript Object Notation) es un formato estándar de estructura
de datos en modo texto, legible y de amplio uso en internet.

.. code:: python

    import pandas as pd
    from pathlib import Path

.. code:: python

    atomos_path = Path.cwd().parent / 'data' / 'atomos'
    print(atomos_path)


.. parsed-literal::

    /home/fiol/Clases/IntPython/clases-python/data/atomos


.. code:: python

    df = pd.read_json(atomos_path / 'atomos.json')
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Element</th>
          <th>Symbol</th>
          <th>Atomic Number</th>
          <th>Atomic Mass (u)</th>
          <th>Density (g/cm³)</th>
          <th>Melting Point (K)</th>
          <th>Boiling Point (K)</th>
          <th>Electronegativity</th>
          <th>State at Room Temp</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Hydrogen</td>
          <td>H</td>
          <td>1</td>
          <td>1.0080</td>
          <td>0.000090</td>
          <td>14.01</td>
          <td>20.28</td>
          <td>2.20</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Helium</td>
          <td>He</td>
          <td>2</td>
          <td>4.0026</td>
          <td>0.000179</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Lithium</td>
          <td>Li</td>
          <td>3</td>
          <td>6.9400</td>
          <td>0.534000</td>
          <td>453.69</td>
          <td>1615.00</td>
          <td>0.98</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Beryllium</td>
          <td>Be</td>
          <td>4</td>
          <td>9.0122</td>
          <td>1.850000</td>
          <td>1560.00</td>
          <td>2742.00</td>
          <td>1.57</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Boron</td>
          <td>B</td>
          <td>5</td>
          <td>10.8100</td>
          <td>2.340000</td>
          <td>2349.00</td>
          <td>4200.00</td>
          <td>2.04</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>5</th>
          <td>Carbon</td>
          <td>C</td>
          <td>6</td>
          <td>12.0110</td>
          <td>2.267000</td>
          <td>3800.00</td>
          <td>4300.00</td>
          <td>2.55</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Nitrogen</td>
          <td>N</td>
          <td>7</td>
          <td>14.0070</td>
          <td>0.001251</td>
          <td>63.15</td>
          <td>77.36</td>
          <td>3.04</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>7</th>
          <td>Oxygen</td>
          <td>O</td>
          <td>8</td>
          <td>15.9990</td>
          <td>0.001429</td>
          <td>54.36</td>
          <td>90.20</td>
          <td>3.44</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>8</th>
          <td>Fluorine</td>
          <td>F</td>
          <td>9</td>
          <td>18.9980</td>
          <td>0.001696</td>
          <td>53.48</td>
          <td>85.03</td>
          <td>3.98</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>9</th>
          <td>Neon</td>
          <td>Ne</td>
          <td>10</td>
          <td>20.1800</td>
          <td>0.000900</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.dtypes




.. parsed-literal::

    Element                object
    Symbol                 object
    Atomic Number           int64
    Atomic Mass (u)       float64
    Density (g/cm³)       float64
    Melting Point (K)     float64
    Boiling Point (K)     float64
    Electronegativity     float64
    State at Room Temp     object
    dtype: object



.. code:: python

    df.columns




.. parsed-literal::

    Index(['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)',
           'Density (g/cm³)', 'Melting Point (K)', 'Boiling Point (K)',
           'Electronegativity', 'State at Room Temp'],
          dtype='object')



Renombremos algunas columnas para que no tengan etiquetas tan complejas

.. code:: python

    df.rename(columns={'Density (g/cm³)': 'Density'}, inplace=True)
    df.rename(columns={'Melting Point (K)': 'Melting Point'}, inplace=True)
    df.columns




.. parsed-literal::

    Index(['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)', 'Density',
           'Melting Point', 'Boiling Point (K)', 'Electronegativity',
           'State at Room Temp'],
          dtype='object')



Extraigamos los datos atómicos (masa y número atómico) y escribámoslo en
un json:

.. code:: python

    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Element</th>
          <th>Symbol</th>
          <th>Atomic Number</th>
          <th>Atomic Mass (u)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Hydrogen</td>
          <td>H</td>
          <td>1</td>
          <td>1.0080</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Helium</td>
          <td>He</td>
          <td>2</td>
          <td>4.0026</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Lithium</td>
          <td>Li</td>
          <td>3</td>
          <td>6.9400</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Beryllium</td>
          <td>Be</td>
          <td>4</td>
          <td>9.0122</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Boron</td>
          <td>B</td>
          <td>5</td>
          <td>10.8100</td>
        </tr>
        <tr>
          <th>5</th>
          <td>Carbon</td>
          <td>C</td>
          <td>6</td>
          <td>12.0110</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Nitrogen</td>
          <td>N</td>
          <td>7</td>
          <td>14.0070</td>
        </tr>
        <tr>
          <th>7</th>
          <td>Oxygen</td>
          <td>O</td>
          <td>8</td>
          <td>15.9990</td>
        </tr>
        <tr>
          <th>8</th>
          <td>Fluorine</td>
          <td>F</td>
          <td>9</td>
          <td>18.9980</td>
        </tr>
        <tr>
          <th>9</th>
          <td>Neon</td>
          <td>Ne</td>
          <td>10</td>
          <td>20.1800</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos.json')

.. code:: python

    # Guarda sólo los valores
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_values.json', orient='values')
    
    # Guarda los registros indexados por el índice del DataFrame
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_index.json', orient='index')
    
    # Guarda los registros indexados por el nombre de las columnas, valor por defecto
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_columns.json', orient='columns')
    
    # Guarda los registros en formato de lista de diccionarios, sin indices
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_records.json', orient='records')


CSV
~~~

Podríamos querer escribirlos como valores separados por comas (u otro
delimitador):

.. code:: python

    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_csv(atomos_path / 'prop_atomos.csv', sep='|')

Vemos que en ambos casos también guarda el índice en el archivo

Si queremos que no guarde el índice, pasamos el argumento opcional
``index=False``.

.. code:: python

    df.to_csv(atomos_path / 'prop_atomos_noindex.csv', sep='|', index=False)

Se puede ver que al guardar el ``.csv``, los elementos inexistentes de
la tabla (``NaN``) se guardan como cadenas de caracteres vacías. Se
puede indicar otro tipo de valor para esos casos:

.. code:: python

    df.to_csv(atomos_path / 'prop_atomos_noheader2.csv', sep='|', index=False, na_rep='N/A')

Formatos binarios
-----------------

En algunos casos como leer o escribir de archivos binarios, es necesario
instalar algunos módulos. Por ejemplo, si queremos leer archivos
``.parquet``, tenemos que instalar ``pyarrow``.

-  ``.parquet``: ``conda install pyarrow``
-  ``.xls(x)``: ``conda install openpyxl xlrd``
-  ``hdf5``: ``conda install pytables``

.. code:: python

    df.to_parquet(atomos_path / 'prop_atomos.parquet')

.. code:: python

    dfp = pd.read_parquet(atomos_path / 'prop_atomos.parquet')
    dfp




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Element</th>
          <th>Symbol</th>
          <th>Atomic Number</th>
          <th>Atomic Mass (u)</th>
          <th>Density</th>
          <th>Melting Point</th>
          <th>Boiling Point (K)</th>
          <th>Electronegativity</th>
          <th>State at Room Temp</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Hydrogen</td>
          <td>H</td>
          <td>1</td>
          <td>1.0080</td>
          <td>0.000090</td>
          <td>14.01</td>
          <td>20.28</td>
          <td>2.20</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Helium</td>
          <td>He</td>
          <td>2</td>
          <td>4.0026</td>
          <td>0.000179</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Lithium</td>
          <td>Li</td>
          <td>3</td>
          <td>6.9400</td>
          <td>0.534000</td>
          <td>453.69</td>
          <td>1615.00</td>
          <td>0.98</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Beryllium</td>
          <td>Be</td>
          <td>4</td>
          <td>9.0122</td>
          <td>1.850000</td>
          <td>1560.00</td>
          <td>2742.00</td>
          <td>1.57</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Boron</td>
          <td>B</td>
          <td>5</td>
          <td>10.8100</td>
          <td>2.340000</td>
          <td>2349.00</td>
          <td>4200.00</td>
          <td>2.04</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>5</th>
          <td>Carbon</td>
          <td>C</td>
          <td>6</td>
          <td>12.0110</td>
          <td>2.267000</td>
          <td>3800.00</td>
          <td>4300.00</td>
          <td>2.55</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Nitrogen</td>
          <td>N</td>
          <td>7</td>
          <td>14.0070</td>
          <td>0.001251</td>
          <td>63.15</td>
          <td>77.36</td>
          <td>3.04</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>7</th>
          <td>Oxygen</td>
          <td>O</td>
          <td>8</td>
          <td>15.9990</td>
          <td>0.001429</td>
          <td>54.36</td>
          <td>90.20</td>
          <td>3.44</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>8</th>
          <td>Fluorine</td>
          <td>F</td>
          <td>9</td>
          <td>18.9980</td>
          <td>0.001696</td>
          <td>53.48</td>
          <td>85.03</td>
          <td>3.98</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>9</th>
          <td>Neon</td>
          <td>Ne</td>
          <td>10</td>
          <td>20.1800</td>
          <td>0.000900</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
      </tbody>
    </table>
    </div>



Web
~~~

.. code:: python

    # URL que contiene una tabla HTML
    url = "https://en.wikipedia.org/wiki/List_of_countries_by_population"
    
    # Leer todas las tablas de la página
    tablas = pd.read_html(url)


.. code:: python

    print(f"Encontré {len(tablas)} tablas")
    print(type(tablas))
    
    # La función devuelve una lista de DataFrames, cada uno correspondiente a una tabla en la página
    # Normalmente querrás seleccionar una tabla específica
    tabla_poblacion = tablas[0]  # Primera tabla de la página
    
    # Mostrar las primeras filas
    tabla_poblacion.head()


.. parsed-literal::

    Encontré 3 tablas
    <class 'list'>




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Location</th>
          <th>Population</th>
          <th>% of world</th>
          <th>Date</th>
          <th>Source (official or from the United Nations)</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>World</td>
          <td>8136397260</td>
          <td>100%</td>
          <td>6 Apr 2025</td>
          <td>UN projection[1][3]</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>1</th>
          <td>India</td>
          <td>1413324000</td>
          <td>17.3%</td>
          <td>1 Mar 2025</td>
          <td>Official projection[4]</td>
          <td>[b]</td>
        </tr>
        <tr>
          <th>2</th>
          <td>China</td>
          <td>1408280000</td>
          <td>17.2%</td>
          <td>31 Dec 2024</td>
          <td>Official estimate[5]</td>
          <td>[c]</td>
        </tr>
        <tr>
          <th>3</th>
          <td>United States</td>
          <td>340110988</td>
          <td>4.2%</td>
          <td>1 Jul 2024</td>
          <td>Official estimate[6]</td>
          <td>[d]</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Indonesia</td>
          <td>282477584</td>
          <td>3.5%</td>
          <td>30 Jun 2024</td>
          <td>National annual projection[7]</td>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    </div>



Cuando se pone difícil
----------------------

En muchas situaciones los archivos pueden tener datos estructurados de
alguna manera que no permiten directamente su lectura con ``pandas``.

.. code:: python

    smn_path = Path.cwd().parent / 'data' / 'smn'

.. code:: python

    pronostico = pd.read_csv(smn_path / 'pronostico_header4.txt')
    pronostico




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>************************************************************************************************</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Producto basado en un modelo de pronóstico numérico del tiempo</th>
          <td></td>
        </tr>
        <tr>
          <th>por lo tanto puede diferir del pronostico emitido por el SMN</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>************************************************************************************************</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>AEROPARQUE</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>================================================================================================</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
        </tr>
        <tr>
          <th>06/DIC/2024 12Hs.        13.1       314 |  12         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>06/DIC/2024 15Hs.        16.2       297 |  15         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>06/DIC/2024 18Hs.        15.2       304 |  23         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>06/DIC/2024 21Hs.         9.1       308 |  17         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>================================================================================================</th>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    <p>187 rows × 1 columns</p>
    </div>



Probemos usando ``read_fwf``, que es capaz de leer tablas con columnas
de ancho fijo:

.. code:: python

    pronostico = pd.read_fwf(smn_path / 'pronostico_header4.txt',skiprows=5)
    pronostico.head(10)





.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>AEROPARQUE</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>==============================================...</td>
        </tr>
        <tr>
          <th>1</th>
          <td>FECHA *          TEMPERATURA      VIENTO      ...</td>
        </tr>
        <tr>
          <th>2</th>
          <td>(DIR | KM/H)</td>
        </tr>
        <tr>
          <th>3</th>
          <td>==============================================...</td>
        </tr>
        <tr>
          <th>4</th>
          <td>02/DIC/2024 00Hs.        16.0       236 |  17 ...</td>
        </tr>
        <tr>
          <th>5</th>
          <td>02/DIC/2024 03Hs.        14.4       196 |  18 ...</td>
        </tr>
        <tr>
          <th>6</th>
          <td>02/DIC/2024 06Hs.        10.6       190 |   8 ...</td>
        </tr>
        <tr>
          <th>7</th>
          <td>02/DIC/2024 09Hs.        14.9       221 |  11 ...</td>
        </tr>
        <tr>
          <th>8</th>
          <td>02/DIC/2024 12Hs.        19.2       249 |  12 ...</td>
        </tr>
        <tr>
          <th>9</th>
          <td>02/DIC/2024 15Hs.        21.6       241 |  15 ...</td>
        </tr>
      </tbody>
    </table>
    </div>



Como se esperaba, no parece ser la solución porque la estructura del
archivo no es estrictamente de columnas de ancho fijo, sino de secciones
de columnas de ancho fijo. Entonces tenemos que preprocesar el archivo
para llegar a obtener esas secciones:

.. code:: python

    with open(smn_path / 'pronostico_5dias20250408.txt', 'r') as file:
        content = file.read()
    
    # Dividir el contenido en secciones por aeropuerto
    sep =  "================================================================================================"
    sections = content.split(sep)
    for i,s in enumerate(sections[0:5]):
        print(f"Sección {i} {'-'*80}")
        print(f"{s}")


.. parsed-literal::

    Sección 0 --------------------------------------------------------------------------------
    ************************************************************************************************
     Producto basado en un modelo de pronóstico numérico del tiempo, 
     por lo tanto puede diferir del pronostico emitido por el SMN
     ************************************************************************************************
     
     AEROPARQUE
     
    Sección 1 --------------------------------------------------------------------------------
    
          FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)                        
     
    Sección 2 --------------------------------------------------------------------------------
    
      08/ABR/2025 00Hs.        15.4       116 |  27         7.5 
      08/ABR/2025 03Hs.        15.6       112 |  25         3.0 
      08/ABR/2025 06Hs.        16.0       114 |  26         3.0 
      08/ABR/2025 09Hs.        16.3       115 |  26         1.7 
      08/ABR/2025 12Hs.        16.6       123 |  22         1.1 
      08/ABR/2025 15Hs.        17.0       123 |  24         0.9 
      08/ABR/2025 18Hs.        16.7       117 |  24         1.8 
      08/ABR/2025 21Hs.        16.6       104 |  22         1.4 
      09/ABR/2025 00Hs.        16.7       100 |  22         0.6 
      09/ABR/2025 03Hs.        16.2       110 |  21         1.2 
      09/ABR/2025 06Hs.        16.0       107 |  18         1.3 
      09/ABR/2025 09Hs.        16.1        99 |  18         1.9 
      09/ABR/2025 12Hs.        17.3        99 |  14         0.7 
      09/ABR/2025 15Hs.        19.9       106 |  19         0.4 
      09/ABR/2025 18Hs.        18.2       104 |  17         0.0 
      09/ABR/2025 21Hs.        17.1       108 |  16         0.0 
      10/ABR/2025 00Hs.        17.1       109 |  15         0.0 
      10/ABR/2025 03Hs.        17.6       104 |  16         0.0 
      10/ABR/2025 06Hs.        17.0        94 |  13         0.0 
      10/ABR/2025 09Hs.        18.2        98 |  13         0.0 
      10/ABR/2025 12Hs.        19.7       102 |  11         0.1 
      10/ABR/2025 15Hs.        21.3       138 |  12         0.0 
      10/ABR/2025 18Hs.        19.5       120 |  14         0.0 
      10/ABR/2025 21Hs.        18.6       109 |   8         0.2 
      11/ABR/2025 00Hs.        17.2        22 |   4         0.0 
      11/ABR/2025 03Hs.        14.8        35 |   6         0.0 
      11/ABR/2025 06Hs.        15.2        26 |   4         0.0 
      11/ABR/2025 09Hs.        17.5        30 |   2         0.0 
      11/ABR/2025 12Hs.        19.6         6 |   3         0.2 
      11/ABR/2025 15Hs.        22.8       326 |   3         0.0 
      11/ABR/2025 18Hs.        20.1       187 |   4         0.0 
      11/ABR/2025 21Hs.        18.2       115 |   3         0.0 
      12/ABR/2025 00Hs.        16.6       292 |   3         0.0 
      12/ABR/2025 03Hs.        15.1       254 |   6         0.0 
      12/ABR/2025 06Hs.        14.4       239 |   6         0.0 
      12/ABR/2025 09Hs.        17.6       213 |   6         0.0 
      12/ABR/2025 12Hs.        22.4       149 |   7         0.0 
      12/ABR/2025 15Hs.        22.8       123 |   8         0.0 
      12/ABR/2025 18Hs.        19.5        72 |   4         0.0 
      12/ABR/2025 21Hs.        17.0        95 |   8         0.0 
     
    Sección 3 --------------------------------------------------------------------------------
    
     AZUL_AERO
     
    Sección 4 --------------------------------------------------------------------------------
    
          FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)                        
     


.. code:: python

    print("Estación : ", sections[0])
    print("Header : ", sections[1])
    print("Pronóstico : ", sections[2])



.. parsed-literal::

    Estación :  ************************************************************************************************
     Producto basado en un modelo de pronóstico numérico del tiempo, 
     por lo tanto puede diferir del pronostico emitido por el SMN
     ************************************************************************************************
     
     AEROPARQUE
     
    Header :  
          FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)                        
     
    Pronóstico :  
      08/ABR/2025 00Hs.        15.4       116 |  27         7.5 
      08/ABR/2025 03Hs.        15.6       112 |  25         3.0 
      08/ABR/2025 06Hs.        16.0       114 |  26         3.0 
      08/ABR/2025 09Hs.        16.3       115 |  26         1.7 
      08/ABR/2025 12Hs.        16.6       123 |  22         1.1 
      08/ABR/2025 15Hs.        17.0       123 |  24         0.9 
      08/ABR/2025 18Hs.        16.7       117 |  24         1.8 
      08/ABR/2025 21Hs.        16.6       104 |  22         1.4 
      09/ABR/2025 00Hs.        16.7       100 |  22         0.6 
      09/ABR/2025 03Hs.        16.2       110 |  21         1.2 
      09/ABR/2025 06Hs.        16.0       107 |  18         1.3 
      09/ABR/2025 09Hs.        16.1        99 |  18         1.9 
      09/ABR/2025 12Hs.        17.3        99 |  14         0.7 
      09/ABR/2025 15Hs.        19.9       106 |  19         0.4 
      09/ABR/2025 18Hs.        18.2       104 |  17         0.0 
      09/ABR/2025 21Hs.        17.1       108 |  16         0.0 
      10/ABR/2025 00Hs.        17.1       109 |  15         0.0 
      10/ABR/2025 03Hs.        17.6       104 |  16         0.0 
      10/ABR/2025 06Hs.        17.0        94 |  13         0.0 
      10/ABR/2025 09Hs.        18.2        98 |  13         0.0 
      10/ABR/2025 12Hs.        19.7       102 |  11         0.1 
      10/ABR/2025 15Hs.        21.3       138 |  12         0.0 
      10/ABR/2025 18Hs.        19.5       120 |  14         0.0 
      10/ABR/2025 21Hs.        18.6       109 |   8         0.2 
      11/ABR/2025 00Hs.        17.2        22 |   4         0.0 
      11/ABR/2025 03Hs.        14.8        35 |   6         0.0 
      11/ABR/2025 06Hs.        15.2        26 |   4         0.0 
      11/ABR/2025 09Hs.        17.5        30 |   2         0.0 
      11/ABR/2025 12Hs.        19.6         6 |   3         0.2 
      11/ABR/2025 15Hs.        22.8       326 |   3         0.0 
      11/ABR/2025 18Hs.        20.1       187 |   4         0.0 
      11/ABR/2025 21Hs.        18.2       115 |   3         0.0 
      12/ABR/2025 00Hs.        16.6       292 |   3         0.0 
      12/ABR/2025 03Hs.        15.1       254 |   6         0.0 
      12/ABR/2025 06Hs.        14.4       239 |   6         0.0 
      12/ABR/2025 09Hs.        17.6       213 |   6         0.0 
      12/ABR/2025 12Hs.        22.4       149 |   7         0.0 
      12/ABR/2025 15Hs.        22.8       123 |   8         0.0 
      12/ABR/2025 18Hs.        19.5        72 |   4         0.0 
      12/ABR/2025 21Hs.        17.0        95 |   8         0.0 
     


La lista ``sections`` contiene secciones que corresponden a una estación
meteorológica, cuyos nombres son:

.. code:: python

    print(sections[0].split('\n')[-2].strip()) # tratamiento especial para remover el comentario
    print(sections[3].strip())
    print(sections[6].strip())


.. parsed-literal::

    AEROPARQUE
    AZUL_AERO
    BAHIA_BLANCA_AERO


   La primer sección debe trabajarse a mano debido al comentario que
   posee el archivo

Las siguientes serían las secciones de headers que en principio no nos
harían falta:

.. code:: python

    print(sections[1].strip())
    print(sections[4].strip())
    print(sections[7].strip())


.. parsed-literal::

    FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)
    FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)
    FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)


Finalmente tenemos las secciones con los datos:

.. code:: python

    print(sections[2].split('\n')[:5])
    print(sections[5].split('\n')[:5])
    print(sections[8].split('\n')[:5])


.. parsed-literal::

    ['', '  08/ABR/2025 00Hs.        15.4       116 |  27         7.5 ', '  08/ABR/2025 03Hs.        15.6       112 |  25         3.0 ', '  08/ABR/2025 06Hs.        16.0       114 |  26         3.0 ', '  08/ABR/2025 09Hs.        16.3       115 |  26         1.7 ']
    ['', '  08/ABR/2025 00Hs.        10.3       109 |  15         0.0 ', '  08/ABR/2025 03Hs.         9.3       124 |  12         0.0 ', '  08/ABR/2025 06Hs.         8.9       134 |  11         0.0 ', '  08/ABR/2025 09Hs.        12.6       122 |  18         0.0 ']
    ['', '  08/ABR/2025 00Hs.        13.5        35 |  20         0.0 ', '  08/ABR/2025 03Hs.        11.7        31 |  16         0.0 ', '  08/ABR/2025 06Hs.        10.7        42 |  12         0.0 ', '  08/ABR/2025 09Hs.        12.6        50 |  15         0.0 ']


Ahora sí podemos usar ``read_fwf`` para transformar las secciones en
``DataFrame``\ s. Para ello tenemos que convertir cada ``section`` (que
es un string) en un tipo de buffer en memoria que se comporte como un
archivo. Obsérvese que si hacemos:

.. code:: python

    from io import StringIO 
    
    with StringIO(sections[5]) as data_io:
        df_malo = pd.read_fwf(data_io)
        
    df_malo.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>08/ABR/2025</th>
          <th>00Hs.</th>
          <th>10.3</th>
          <th>109</th>
          <th>|</th>
          <th>15</th>
          <th>0.0</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>9.3</td>
          <td>124</td>
          <td>|</td>
          <td>12</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>8.9</td>
          <td>134</td>
          <td>|</td>
          <td>11</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>12.6</td>
          <td>122</td>
          <td>|</td>
          <td>18</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>19.4</td>
          <td>95</td>
          <td>|</td>
          <td>22</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>15Hs.</td>
          <td>21.4</td>
          <td>99</td>
          <td>|</td>
          <td>28</td>
          <td>0.0</td>
        </tr>
      </tbody>
    </table>
    </div>



Es decir que la primer fila del *stream* es tomada como los nombres de
las columnas. Tenemos que pasar el argumento opcional ``names`` para
definir los nombres de las columnas:

.. code:: python

    with StringIO(sections[2]) as data_io:
        df = pd.read_fwf(data_io,names=['fecha','h','t','v_dir','l','v_vel','precip'])
        
    df.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>fecha</th>
          <th>h</th>
          <th>t</th>
          <th>v_dir</th>
          <th>l</th>
          <th>v_vel</th>
          <th>precip</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>00Hs.</td>
          <td>15.4</td>
          <td>116</td>
          <td>|</td>
          <td>27</td>
          <td>7.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>15.6</td>
          <td>112</td>
          <td>|</td>
          <td>25</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>16.0</td>
          <td>114</td>
          <td>|</td>
          <td>26</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>16.3</td>
          <td>115</td>
          <td>|</td>
          <td>26</td>
          <td>1.7</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>16.6</td>
          <td>123</td>
          <td>|</td>
          <td>22</td>
          <td>1.1</td>
        </tr>
      </tbody>
    </table>
    </div>



Para terminar podemos eliminar la columna ``l`` que no aporta
información:

.. code:: python

    df.drop(columns=['l'],inplace=True)
    df.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>fecha</th>
          <th>h</th>
          <th>t</th>
          <th>v_dir</th>
          <th>v_vel</th>
          <th>precip</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>00Hs.</td>
          <td>15.4</td>
          <td>116</td>
          <td>27</td>
          <td>7.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>15.6</td>
          <td>112</td>
          <td>25</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>16.0</td>
          <td>114</td>
          <td>26</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>16.3</td>
          <td>115</td>
          <td>26</td>
          <td>1.7</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>16.6</td>
          <td>123</td>
          <td>22</td>
          <td>1.1</td>
        </tr>
      </tbody>
    </table>
    </div>



--------------

Ejercicio 14(a)
===============

1. Complete la tabla de datos del ejemplo de clase. Para ello utilice el
   archivo con los pronósticos completos para todas las estaciones,
   ``pronostico_5dias20250408.txt`` y

-  Agregue una columna con el nombre de la estación al DataFrame
-  Procese todas las estaciones

--------------



Estructuras de datos en ``pandas``: Series
==========================================

Las series son un objeto unidimensional que contiene una secuencia de
valores *del mismo tipo* y un conjunto de etiquetas denominado *índice*:

.. code:: python

    import numpy as np
    import pandas as pd 

.. code:: python

    s = pd.Series([1,4,4,2])
    print(s)
    print(type(s))
    print(s.dtype)


.. parsed-literal::

    0    1
    1    4
    2    4
    3    2
    dtype: int64
    <class 'pandas.core.series.Series'>
    int64


En este ejemplo, ``s`` es una serie que contiene elementos ``int64``.

   Los tipos de datos son extensiones de aquellos que utiliza ``numpy``.

..

   Notar que usando directamente la función ``print`` obtenemos una
   representación textual de la serie.

Se puede acceder a los valores de la serie con el método ``.array``, y a
los índices con el método ``.index``:

.. code:: python

    s.array




.. parsed-literal::

    <NumpyExtensionArray>
    [1, 4, 4, 2]
    Length: 4, dtype: int64



El tipo ``NumpyExtensionArray`` es una clase que encapsula al tipo array
de ``numpy``, pero ha permitido agregarle flexibilidad para acomodar las
características de datos más generales.

Por otra parte, los índices se obtienen como:

.. code:: python

    s.index 




.. parsed-literal::

    RangeIndex(start=0, stop=4, step=1)



Los índices son inmutables, en el mismo sentido que los caracteres de un
string. Es decir, no se pueden cambiar ciertos índices, pero se puede
*reasignar* el índice de una serie completamente:

.. code:: python

    print(s.index[2])
    s.index[2] = 5


.. parsed-literal::

    2


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[5], line 2
          1 print(s.index[2])
    ----> 2 s.index[2] = 5


    File /usr/lib64/python3.13/site-packages/pandas/core/indexes/base.py:5371, in Index.__setitem__(self, key, value)
       5369 @final
       5370 def __setitem__(self, key, value) -> None:
    -> 5371     raise TypeError("Index does not support mutable operations")


    TypeError: Index does not support mutable operations


.. code:: python

    nuevo_index = index=['a','b','c','d']
    s.index = nuevo_index
    print(s)


.. parsed-literal::

    a    1
    b    4
    c    4
    d    2
    dtype: int64


Se puede también construir una nueva serie indicando los índices
específicamente en el constructor con el argumento ``index=``:

.. code:: python

    s2 = pd.Series([1,4,4,2], index=['arquero','defensores','medios','delanteros'])
    print(s2)


.. parsed-literal::

    arquero       1
    defensores    4
    medios        4
    delanteros    2
    dtype: int64


Existen otras maneras de crear series en ``pandas``, como por ejemplo a
partir de arreglos de ``numpy``

.. code:: python

    rnd = pd.Series(np.random.randn(5))
    print(rnd)


.. parsed-literal::

    0    0.370947
    1    1.600918
    2    0.161127
    3   -0.929294
    4   -0.121632
    dtype: float64


A partir de otras variables

.. code:: python

    values = [1,2,3,4,5]
    index = ['a','b','c','d','e']
    s3 = pd.Series(values, index=index)
    s3




.. parsed-literal::

    a    1
    b    2
    c    3
    d    4
    e    5
    dtype: int64



o usando diccionarios:

.. code:: python

    d = { 1: "a", 2: "b", 3: "c", 4: "d", 5: "e" }
    s4 = pd.Series(d,dtype='string')
    print(s4)


.. parsed-literal::

    1    a
    2    b
    3    c
    4    d
    5    e
    dtype: string


Asimismo, se puede usar el argumento ``dtype`` (igual que en NumPy) para
indicar el tipo de dato que se quiere utilizar al crear la serie. Pandas
soporta los tipos de datos de NumPy, además de proveer sus propios tipos
de datos (por ejemplo, ``string``) propios

.. code:: python

    n = pd.Series([4,5,6], dtype='string')
    print(n)
    print(n[0]+n[1])


.. parsed-literal::

    0    4
    1    5
    2    6
    dtype: string
    45


Accediendo a los valores
------------------------

Se puede acceder a los valores de una serie a través del índice como si
fuera un array:

.. code:: python

    s = pd.Series([ 4, 8, 15, 16, 23, 42 ],index = ['a','b','c','d','e','f'])
    print(s)


.. parsed-literal::

    a     4
    b     8
    c    15
    d    16
    e    23
    f    42
    dtype: int64


.. code:: python

    print(f"Tercer elemento: {s.array[2]}")
    s.array[2] = 108
    print(s.array)
    
    print(f"Con un rango:\n{s[1:3]}")
    print(f"Con los índices:\n{s[['a','c']]}")
    print(f"Con una máscara:\n{s[s > 100]}")


.. parsed-literal::

    Tercer elemento: 15
    <NumpyExtensionArray>
    [4, 8, 108, 16, 23, 42]
    Length: 6, dtype: int64
    Con un rango:
    b      8
    c    108
    dtype: int64
    Con los índices:
    a      4
    c    108
    dtype: int64
    Con una máscara:
    c    108
    dtype: int64


.. code:: python

    print(f"Con una lista de índices:\n{s[[0,1]]}")


.. parsed-literal::

    Con una lista de índices:
    a    4
    b    8
    dtype: int64


.. parsed-literal::

    /tmp/ipykernel_213536/1722261588.py:1: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
      print(f"Con una lista de índices:\n{s[[0,1]]}")


.. code:: python

    print(f"Con una lista de índices:\n{s.iloc[[0,3]]}") 
    print(f"Con una lista de índices:\n{s[ s.index[[0,3]] ]}")


.. parsed-literal::

    Con una lista de índices:
    a     4
    d    16
    dtype: int64
    Con una lista de índices:
    a     4
    d    16
    dtype: int64


Modificando valores
-------------------

Para modificar un valor dentro de una serie de ``pandas``, se accede al
mismo con la etiqueta correspondiente:

.. code:: python

    v = pd.Series([1,2,3,4,5], index=['a','b','c','d','e'])
    print(v)
    v['b'] = 100
    print(v)


.. parsed-literal::

    a    1
    b    2
    c    3
    d    4
    e    5
    dtype: int64
    a      1
    b    100
    c      3
    d      4
    e      5
    dtype: int64


En caso en que dicha etiqueta no exista dentro del índice de la serie,
se agrega el valor:

.. code:: python

    v['f'] = 200
    print(v)


.. parsed-literal::

    a      1
    b    100
    c      3
    d      4
    e      5
    f    200
    dtype: int64


Para eliminar valores, se utiliza el método ``.drop``. Por defecto se
genera una nueva serie con el valor eliminado, para poder eliminar el
valor en la misma serie, es necesario usar el argumento opcional
``inplace`` como ``True``.

.. code:: python

    w = v.drop('b')
    print(v)
    print(w)


.. parsed-literal::

    a      1
    b    100
    c      3
    d      4
    e      5
    f    200
    dtype: int64
    a      1
    c      3
    d      4
    e      5
    f    200
    dtype: int64


.. code:: python

    v.drop('b', inplace=True)
    print(v)


.. parsed-literal::

    a      1
    c      3
    d      4
    e      5
    f    200
    dtype: int64


.. code:: python

    # Generando un nuevo objeto
    print(v==w)
    # Comparando objetos
    print(f"v is w: {v is w}")
    print(f"v equals w: {v.equals(w)}")


.. parsed-literal::

    a    True
    c    True
    d    True
    e    True
    f    True
    dtype: bool
    v is w: False
    v equals w: True


.. code:: python

    v.drop(['b'], inplace=True) # KeyError: "['b'] not found in axis"


::


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    Cell In[21], line 1
    ----> 1 v.drop(['b'], inplace=True) # KeyError: "['b'] not found in axis"


    File /usr/lib64/python3.13/site-packages/pandas/core/series.py:5347, in Series.drop(self, labels, axis, index, columns, level, inplace, errors)
       5250 def drop(
       5251     self,
       5252     labels: IndexLabel | None = None,
       (...)
       5259     errors: IgnoreRaise = "raise",
       5260 ) -> Series | None:
       5261     """
       5262     Return Series with specified index labels removed.
       5263 
       (...)
       5345     dtype: float64
       5346     """
    -> 5347     return super().drop(
       5348         labels=labels,
       5349         axis=axis,
       5350         index=index,
       5351         columns=columns,
       5352         level=level,
       5353         inplace=inplace,
       5354         errors=errors,
       5355     )


    File /usr/lib64/python3.13/site-packages/pandas/core/generic.py:4785, in NDFrame.drop(self, labels, axis, index, columns, level, inplace, errors)
       4783 for axis, labels in axes.items():
       4784     if labels is not None:
    -> 4785         obj = obj._drop_axis(labels, axis, level=level, errors=errors)
       4787 if inplace:
       4788     self._update_inplace(obj)


    File /usr/lib64/python3.13/site-packages/pandas/core/generic.py:4827, in NDFrame._drop_axis(self, labels, axis, level, errors, only_slice)
       4825         new_axis = axis.drop(labels, level=level, errors=errors)
       4826     else:
    -> 4827         new_axis = axis.drop(labels, errors=errors)
       4828     indexer = axis.get_indexer(new_axis)
       4830 # Case for non-unique axis
       4831 else:


    File /usr/lib64/python3.13/site-packages/pandas/core/indexes/base.py:7070, in Index.drop(self, labels, errors)
       7068 if mask.any():
       7069     if errors != "ignore":
    -> 7070         raise KeyError(f"{labels[mask].tolist()} not found in axis")
       7071     indexer = indexer[~mask]
       7072 return self.delete(indexer)


    KeyError: "['b'] not found in axis"


Tipos de datos
~~~~~~~~~~~~~~

Como último comentario, obsérvese que si uno pretende crear una serie
con valores de distinto tipo, el tipo de la serie se promueve al tipo
general ``object``, sin embargo cada elemento es reconocido con su tipo
particular:

.. code:: python

    s = pd.Series([1,'a','b','c'])
    print(s)
    for index,elem in s.items(): 
        print(f"Tipo de objeto del elemento {index}: {type(s[index])}")


.. parsed-literal::

    0    1
    1    a
    2    b
    3    c
    dtype: object
    Tipo de objeto del elemento 0: <class 'int'>
    Tipo de objeto del elemento 1: <class 'str'>
    Tipo de objeto del elemento 2: <class 'str'>
    Tipo de objeto del elemento 3: <class 'str'>


.. code:: python

    print(f"Suma de enteros: {s[0] + 3}")
    print(f"Suma de enteros: {s[1] + 3}") # Error


.. parsed-literal::

    Suma de enteros: 4


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[23], line 2
          1 print(f"Suma de enteros: {s[0] + 3}")
    ----> 2 print(f"Suma de enteros: {s[1] + 3}") # Error


    TypeError: can only concatenate str (not "int") to str


.. code:: python

    print(f"Concat de str  : {s[1] + 'd'}")
    print(f"Concat de str  : {s[1] + 3}") # Error


.. parsed-literal::

    Concat de str  : ad


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[24], line 2
          1 print(f"Concat de str  : {s[1] + 'd'}")
    ----> 2 print(f"Concat de str  : {s[1] + 3}") # Error


    TypeError: can only concatenate str (not "int") to str


Si bien entonces se pueden usar series con objetos con distintos tipos,
se recomienda que el tipo de dato sea homogéneo.

Valores que faltan
------------------

Es muy común al procesar datos que uno encuentre valores que no existen.
La manera en que ``pandas`` representa estos datos faltantes es a través
de ``np.nan``, el tipo de dato de ``numpy`` que representa *not a
number*, para aquellos tipos de datos heredados de ``numpy``:

.. code:: python

    snan = pd.Series([1,4,np.nan,2])
    print(snan)


.. parsed-literal::

    0    1.0
    1    4.0
    2    NaN
    3    2.0
    dtype: float64


   Notar que si bien los datos existentes son de tipo entero, al
   utilizar ``np.nan`` para representar un dato inexistente, el tipo de
   dato de la serie se promueve a ``float64``.

De la misma forma, se puede usar ``None`` para representar el dato
faltante:

.. code:: python

    snone = pd.Series([1,4,None,5])
    print(snone)


.. parsed-literal::

    0    1.0
    1    4.0
    2    NaN
    3    5.0
    dtype: float64


En el caso de cadenas de caracteres, se puede usar ``np.nan`` o
``None``. Si no se indica el tipo de dato a través de ``dtype``, se
promueve el tipo de dato de la serie a ``object``, como sucede por
defecto.

.. code:: python

    smixed_str = pd.Series(['a','b',np.nan,None,'d'])
    smixed_str




.. parsed-literal::

    0       a
    1       b
    2     NaN
    3    None
    4       d
    dtype: object



Esto tiene el inconveniente evidente de que el elemento faltante no está
representado unívocamente por un solo valor. Para solventar este
problema, se puede crear la serie con el tipo ``string``:

.. code:: python

    smixed_str2 = pd.Series(['a','b',np.nan,None,'d'],dtype='string')
    print(smixed_str2)


.. parsed-literal::

    0       a
    1       b
    2    <NA>
    3    <NA>
    4       d
    dtype: string


En este caso, el singlete ``NA`` representa unívocamente el dato
faltante. En cualquier caso, se cuenta con el método ``.isna``, que
retorna una serie de ``boolean`` donde los valores faltantes son
verdaderos (``True``):

.. code:: python

    print(smixed_str.isna())
    print(smixed_str2.isna())


.. parsed-literal::

    0    False
    1    False
    2     True
    3     True
    4    False
    dtype: bool
    0    False
    1    False
    2     True
    3     True
    4    False
    dtype: bool


   Atención, la cadena de caracteres vacía ``''`` *NO* se considera un
   dato inexistente.

Puede ser útil en algunos casos poder filtrar los datos inexistentes.
Para eso se utiliza el método ``.dropna``, que crea una nueva serie sin
dichos datos:

.. code:: python

    print(smixed_str)
    print(smixed_str.dropna())


.. parsed-literal::

    0       a
    1       b
    2     NaN
    3    None
    4       d
    dtype: object
    0    a
    1    b
    4    d
    dtype: object


Operando con series
-------------------

Las operaciones con series han sido diseñadas para que sean compatibles
con NumPy, y sigan las convenciones de Python. He aquí algunos ejemplos:

.. code:: python

    ones = pd.Series(np.ones(8))*0.5
    print(ones)
    
    t = pd.Series(np.random.rand(8))
    print(t)
    print(t.mean())


.. parsed-literal::

    0    0.5
    1    0.5
    2    0.5
    3    0.5
    4    0.5
    5    0.5
    6    0.5
    7    0.5
    dtype: float64
    0    0.855919
    1    0.316680
    2    0.188950
    3    0.535831
    4    0.767803
    5    0.836171
    6    0.225345
    7    0.559054
    dtype: float64
    0.5357193052760575


.. code:: python

    shifted = t - ones 
    print(shifted)
    print(shifted.mean())
    print(np.abs(shifted))


.. parsed-literal::

    0    0.355919
    1   -0.183320
    2   -0.311050
    3    0.035831
    4    0.267803
    5    0.336171
    6   -0.274655
    7    0.059054
    dtype: float64
    0.0357193052760575
    0    0.355919
    1    0.183320
    2    0.311050
    3    0.035831
    4    0.267803
    5    0.336171
    6    0.274655
    7    0.059054
    dtype: float64


Además de poder interactuar con NumPy en forma transparente, existen
algunos métodos útiles para trabajar con los datos de una serie:

.. code:: python

    data = {'Pedro':19, 'Oscar': 30, 'Carlos': 27, 'David': 26}
    seru = pd.Series(data)
    print("Person Series:\n")
    print(seru)
    
    # Perform operations on the Series
    print("Edad promedio:", seru.mean())
    print("Edad del más viejo :", seru.max())
    print("El más viejo :", seru.idxmax())


.. parsed-literal::

    Person Series:
    
    Pedro     19
    Oscar     30
    Carlos    27
    David     26
    dtype: int64
    Edad promedio: 25.5
    Edad del más viejo : 30
    El más viejo : Oscar


.. code:: python

    temperaturas_ciudades = {
        "Buenos Aires": 17.6,
        "Córdoba": 18.0,
        "Rosario": 18.0,
        "Mendoza": 16.0,
        "Santa Fe": 21.3
    
    }
    temp = pd.Series(temperaturas_ciudades)
    print(temp)


.. parsed-literal::

    Buenos Aires    17.6
    Córdoba         18.0
    Rosario         18.0
    Mendoza         16.0
    Santa Fe        21.3
    dtype: float64


.. code:: python

    otras_ciudades = ['Buenos Aires', 'Córdoba', 'Rosario', 'Mendoza', 'Salta']
    temp = pd.Series(temperaturas_ciudades, index=otras_ciudades)
    print(temp)


.. parsed-literal::

    Buenos Aires    17.6
    Córdoba         18.0
    Rosario         18.0
    Mendoza         16.0
    Salta            NaN
    dtype: float64


.. code:: python

    temp_ciudades2 = {
        "Mendoza": 20.0,
        "Salta": 17.2,
        "Santa Fe": 18.6,
        "San Juan": 19.3
    }
    temp2 = pd.Series(temp_ciudades2)
    temp2




.. parsed-literal::

    Mendoza     20.0
    Salta       17.2
    Santa Fe    18.6
    San Juan    19.3
    dtype: float64



.. code:: python

    print(temp)


.. parsed-literal::

    Buenos Aires    17.6
    Córdoba         18.0
    Rosario         18.0
    Mendoza         16.0
    Salta            NaN
    dtype: float64


.. code:: python

    print((temp + temp2)/2)


.. parsed-literal::

    Buenos Aires     NaN
    Córdoba          NaN
    Mendoza         18.0
    Rosario          NaN
    Salta            NaN
    San Juan         NaN
    Santa Fe         NaN
    dtype: float64


Misceláneas
-----------

Algunas otras operaciones interesantes:

.. code:: python

    'Rosario' in temp2




.. parsed-literal::

    False



.. code:: python

    temp2_dict = temp2.to_dict()
    print(temp2_dict)
    print(type(temp2_dict))


.. parsed-literal::

    {'Mendoza': 20.0, 'Salta': 17.2, 'Santa Fe': 18.6, 'San Juan': 19.3}
    <class 'dict'>


.. code:: python

    temp2_json = temp2.to_json() 
    print(temp2_json)
    print(type(temp2_json))


.. parsed-literal::

    {"Mendoza":20.0,"Salta":17.2,"Santa Fe":18.6,"San Juan":19.3}
    <class 'str'>


--------------

Ejercicios 14(b)
================

2. Si no lo ha adivinado, los datos de la serie ``seru`` corresponden a
   las edades de los integrantes de la banda Serú Girán, al momento de
   conformarse, en el año 1978. Encuentre los años de nacimiento de cada
   uno de sus integrantes.

3. Una de las funciones más usadas en redes neuronales es *softmax*,
   cuyo objetivo es convertir los resultados de las distintas etapas del
   procesamiento de una red en probabilidades. Los primeros pueden ser
   números reales de cualquier valor, mientras que las probabilidades
   deben estar acotadas al intervalo [0,1]. La función *softmax*
   aplicada a un conjunto de valores :math:`z_1,\cdots,z_n` se calcula
   como

   .. math::


      \sigma(z_i) = \frac {e^{z_i}} { \sum_{i=1}^n e^{z_i}}

   -  Cree una serie con 10 valores al azar entre 0 y 5
   -  Obtenga la serie resultante de la aplicación de *softmax* a la
      serie anterior

4. El siguiente es un diccionario que representa el consumo eléctrico
   mensual de ciertos artefactos eléctricos:

   .. code:: python

      consumo_electrico = {
        "Artefacto": [
           "Heladera", "Lavarropa", "Microondas", "Aire Acondicionado", 
           "Televisor", "Computadora", "Lámpara LED", "Secador de Pelo", 
           "Horno Eléctrico", "Ventilador"
        ],
        "Consumo Promedio (kWh/mes)": [
           30, 10, 15, 120, 20, 12, 2, 3, 25, 8
        ]
      }

   -  Obtenga los tres artefactos de mayor consumo.
   -  Encuentre los artefactos que consumen más de 15 kWH/mes.
   -  Calcule el consumo anual de cada artefacto, y el costo que implica
      suponiendo que el precio del kWH/mes es de $3145.

5. Un problema de índices enteros. Supongamos que tenemos la serie

   .. code:: python

      s = pd.Series(np.arange(3.0))

   es decir,

   .. code:: python

       0    0.0
       1    1.0
       2    2.0
       dtype: float64

   ¿Cuál es el resultado esperado de s[-1]? ¿Cuál es el real? Evalúe
   ``s[-2:-1]`` y también ``s.iloc[-1]``. Considere ahora la serie

   .. code:: python

      s = pd.Series(np.arange(3.0), index=['a','b','c'])

   y evalúe nuevamente ``s[-1]``. ¿Qué conclusiones puede sacar?

--------------
