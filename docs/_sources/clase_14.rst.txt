.. _clase_14:


====================================
Clase 14: Introducción a ``pandas``
====================================

=========================

El análisis y consumo de grandes cantidades de información requiere
herramientas que permitan limpiar, filtrar, agrupar los datos. Una de
las bibliotecas fundamentales para ello es ``pandas``. ``pandas``
contiene estructuras de datos y funciones que permiten la manipulación
de los datos en forma rápida. ``pandas`` está inspirada fuertemente en
``numpy``, en el sentido en que adopta en su diseño el estilo idiomático
de ``numpy``. La diferencia principal radica en que ``numpy`` se utiliza
para conjuntos de datos homogéneos, mientras que ``pandas`` está
diseñada para trabajar con tablas o datos heterogéneos.

Otra biblioteca con características similares es
`polars <https://docs.pola.rs/>`__

Input/Output con ``pandas``
===========================

Para poder leer o escribir datos, ``pandas`` provee una serie de métodos
específicos para todos los tipos de datos estructurados usuales, ya sea
en formato texto o binario. Los métodos para leer de archivos se
reconocen por el prefijo ``.read_``, mientras que para escribir usaremos
``.to_``. Para cada formato particular de archivo, estos métodos
aceptarán un conjunto de argumentos adicionales que permiten adecuar
nuestro código.

   Si se usa VSCode, se puede instalar la extensión `Data
   Wrangler <https://marketplace.visualstudio.com/items?itemName=ms-toolsai.datawrangler>`__
   que permite inspeccionar ``DataFrames``. Puede ser útil cuando uno
   trabaja con muchos datos.

JSON
----

JSON (JavaScript Object Notation) es un formato estándar de estructura
de datos en modo texto, legible y de amplio uso en internet.

.. code:: python

    import pandas as pd
    from pathlib import Path

.. code:: python

    atomos_path = Path.cwd().parent / 'data' / 'atomos'
    print(atomos_path)


.. parsed-literal::

    /Users/flavioc/Library/Mobile Documents/com~apple~CloudDocs/Documents/cursos/Python/GitLab/clase-python/data/atomos


.. code:: python

    df = pd.read_json(atomos_path / 'atomos.json')
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Element</th>
          <th>Symbol</th>
          <th>Atomic Number</th>
          <th>Atomic Mass (u)</th>
          <th>Density (g/cm³)</th>
          <th>Melting Point (K)</th>
          <th>Boiling Point (K)</th>
          <th>Electronegativity</th>
          <th>State at Room Temp</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Hydrogen</td>
          <td>H</td>
          <td>1</td>
          <td>1.0080</td>
          <td>0.000090</td>
          <td>14.01</td>
          <td>20.28</td>
          <td>2.20</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Helium</td>
          <td>He</td>
          <td>2</td>
          <td>4.0026</td>
          <td>0.000179</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Lithium</td>
          <td>Li</td>
          <td>3</td>
          <td>6.9400</td>
          <td>0.534000</td>
          <td>453.69</td>
          <td>1615.00</td>
          <td>0.98</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Beryllium</td>
          <td>Be</td>
          <td>4</td>
          <td>9.0122</td>
          <td>1.850000</td>
          <td>1560.00</td>
          <td>2742.00</td>
          <td>1.57</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Boron</td>
          <td>B</td>
          <td>5</td>
          <td>10.8100</td>
          <td>2.340000</td>
          <td>2349.00</td>
          <td>4200.00</td>
          <td>2.04</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>5</th>
          <td>Carbon</td>
          <td>C</td>
          <td>6</td>
          <td>12.0110</td>
          <td>2.267000</td>
          <td>3800.00</td>
          <td>4300.00</td>
          <td>2.55</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Nitrogen</td>
          <td>N</td>
          <td>7</td>
          <td>14.0070</td>
          <td>0.001251</td>
          <td>63.15</td>
          <td>77.36</td>
          <td>3.04</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>7</th>
          <td>Oxygen</td>
          <td>O</td>
          <td>8</td>
          <td>15.9990</td>
          <td>0.001429</td>
          <td>54.36</td>
          <td>90.20</td>
          <td>3.44</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>8</th>
          <td>Fluorine</td>
          <td>F</td>
          <td>9</td>
          <td>18.9980</td>
          <td>0.001696</td>
          <td>53.48</td>
          <td>85.03</td>
          <td>3.98</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>9</th>
          <td>Neon</td>
          <td>Ne</td>
          <td>10</td>
          <td>20.1800</td>
          <td>0.000900</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.dtypes




.. parsed-literal::

    Element                object
    Symbol                 object
    Atomic Number           int64
    Atomic Mass (u)       float64
    Density (g/cm³)       float64
    Melting Point (K)     float64
    Boiling Point (K)     float64
    Electronegativity     float64
    State at Room Temp     object
    dtype: object



.. code:: python

    df.columns




.. parsed-literal::

    Index(['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)',
           'Density (g/cm³)', 'Melting Point (K)', 'Boiling Point (K)',
           'Electronegativity', 'State at Room Temp'],
          dtype='object')



Renombremos algunas columnas para que no tengan etiquetas tan complejas

.. code:: python

    df.rename(columns={'Density (g/cm³)': 'Density'}, inplace=True)
    df.rename(columns={'Melting Point (K)': 'Melting Point'}, inplace=True)
    df.columns




.. parsed-literal::

    Index(['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)', 'Density',
           'Melting Point', 'Boiling Point (K)', 'Electronegativity',
           'State at Room Temp'],
          dtype='object')



Extraigamos los datos atómicos (masa y número atómico) y escribámoslo en
un json:

.. code:: python

    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Element</th>
          <th>Symbol</th>
          <th>Atomic Number</th>
          <th>Atomic Mass (u)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Hydrogen</td>
          <td>H</td>
          <td>1</td>
          <td>1.0080</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Helium</td>
          <td>He</td>
          <td>2</td>
          <td>4.0026</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Lithium</td>
          <td>Li</td>
          <td>3</td>
          <td>6.9400</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Beryllium</td>
          <td>Be</td>
          <td>4</td>
          <td>9.0122</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Boron</td>
          <td>B</td>
          <td>5</td>
          <td>10.8100</td>
        </tr>
        <tr>
          <th>5</th>
          <td>Carbon</td>
          <td>C</td>
          <td>6</td>
          <td>12.0110</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Nitrogen</td>
          <td>N</td>
          <td>7</td>
          <td>14.0070</td>
        </tr>
        <tr>
          <th>7</th>
          <td>Oxygen</td>
          <td>O</td>
          <td>8</td>
          <td>15.9990</td>
        </tr>
        <tr>
          <th>8</th>
          <td>Fluorine</td>
          <td>F</td>
          <td>9</td>
          <td>18.9980</td>
        </tr>
        <tr>
          <th>9</th>
          <td>Neon</td>
          <td>Ne</td>
          <td>10</td>
          <td>20.1800</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos.json')

.. code:: python

    # Guarda sólo los valores
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_values.json', orient='values')
    
    # Guarda los registros indexados por el índice del DataFrame
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_index.json', orient='index')
    
    # Guarda los registros indexados por el nombre de las columnas, valor por defecto
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_columns.json', orient='columns')
    
    # Guarda los registros en formato de lista de diccionarios, sin indices
    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_json(atomos_path / 'prop_atomos_records.json', orient='records')


CSV
~~~

Podríamos querer escribirlos como valores separados por comas (u otro
delimitador):

.. code:: python

    df[['Element', 'Symbol', 'Atomic Number', 'Atomic Mass (u)']].to_csv(atomos_path / 'prop_atomos.csv', sep='|')

Vemos que en ambos casos también guarda el índice en el archivo

Si queremos que no guarde el índice, pasamos el argumento opcional
``index=False``.

.. code:: python

    df.to_csv(atomos_path / 'prop_atomos_noindex.csv', sep='|', index=False)

Se puede ver que al guardar el ``.csv``, los elementos inexistentes de
la tabla (``NaN``) se guardan como cadenas de caracteres vacías. Se
puede indicar otro tipo de valor para esos casos:

.. code:: python

    df.to_csv(atomos_path / 'prop_atomos_noheader2.csv', sep='|', index=False, na_rep='N/A')

Formatos binarios
-----------------

En algunos casos como leer o escribir de archivos binarios, es necesario
instalar algunos módulos. Por ejemplo, si queremos leer archivos
``.parquet``, tenemos que instalar ``pyarrow``.

-  ``.parquet``: ``conda install pyarrow``
-  ``.xls(x)``: ``conda install openpyxl xlrd``
-  ``hdf5``: ``conda install pytables``

.. code:: python

    df.to_parquet(atomos_path / 'prop_atomos.parquet')

.. code:: python

    dfp = pd.read_parquet(atomos_path / 'prop_atomos.parquet')
    dfp




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Element</th>
          <th>Symbol</th>
          <th>Atomic Number</th>
          <th>Atomic Mass (u)</th>
          <th>Density</th>
          <th>Melting Point</th>
          <th>Boiling Point (K)</th>
          <th>Electronegativity</th>
          <th>State at Room Temp</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Hydrogen</td>
          <td>H</td>
          <td>1</td>
          <td>1.0080</td>
          <td>0.000090</td>
          <td>14.01</td>
          <td>20.28</td>
          <td>2.20</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Helium</td>
          <td>He</td>
          <td>2</td>
          <td>4.0026</td>
          <td>0.000179</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Lithium</td>
          <td>Li</td>
          <td>3</td>
          <td>6.9400</td>
          <td>0.534000</td>
          <td>453.69</td>
          <td>1615.00</td>
          <td>0.98</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Beryllium</td>
          <td>Be</td>
          <td>4</td>
          <td>9.0122</td>
          <td>1.850000</td>
          <td>1560.00</td>
          <td>2742.00</td>
          <td>1.57</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Boron</td>
          <td>B</td>
          <td>5</td>
          <td>10.8100</td>
          <td>2.340000</td>
          <td>2349.00</td>
          <td>4200.00</td>
          <td>2.04</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>5</th>
          <td>Carbon</td>
          <td>C</td>
          <td>6</td>
          <td>12.0110</td>
          <td>2.267000</td>
          <td>3800.00</td>
          <td>4300.00</td>
          <td>2.55</td>
          <td>Solid</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Nitrogen</td>
          <td>N</td>
          <td>7</td>
          <td>14.0070</td>
          <td>0.001251</td>
          <td>63.15</td>
          <td>77.36</td>
          <td>3.04</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>7</th>
          <td>Oxygen</td>
          <td>O</td>
          <td>8</td>
          <td>15.9990</td>
          <td>0.001429</td>
          <td>54.36</td>
          <td>90.20</td>
          <td>3.44</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>8</th>
          <td>Fluorine</td>
          <td>F</td>
          <td>9</td>
          <td>18.9980</td>
          <td>0.001696</td>
          <td>53.48</td>
          <td>85.03</td>
          <td>3.98</td>
          <td>Gas</td>
        </tr>
        <tr>
          <th>9</th>
          <td>Neon</td>
          <td>Ne</td>
          <td>10</td>
          <td>20.1800</td>
          <td>0.000900</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>Gas</td>
        </tr>
      </tbody>
    </table>
    </div>



Web
~~~

.. code:: python

    # URL que contiene una tabla HTML
    url = "https://en.wikipedia.org/wiki/List_of_countries_by_population"
    
    # Leer todas las tablas de la página
    tablas = pd.read_html(url)


.. code:: python

    print(f"Encontré {len(tablas)} tablas")
    print(type(tablas))
    
    # La función devuelve una lista de DataFrames, cada uno correspondiente a una tabla en la página
    # Normalmente querrás seleccionar una tabla específica
    tabla_poblacion = tablas[0]  # Primera tabla de la página
    
    # Mostrar las primeras filas
    tabla_poblacion.head()


.. parsed-literal::

    Encontré 3 tablas
    <class 'list'>




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Location</th>
          <th>Population</th>
          <th>% of world</th>
          <th>Date</th>
          <th>Source (official or from the United Nations)</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>World</td>
          <td>8137000000</td>
          <td>100%</td>
          <td>10 Apr 2025</td>
          <td>UN projection[1][3]</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>1</th>
          <td>India</td>
          <td>1413324000</td>
          <td>17.3%</td>
          <td>1 Mar 2025</td>
          <td>Official projection[4]</td>
          <td>[b]</td>
        </tr>
        <tr>
          <th>2</th>
          <td>China</td>
          <td>1408280000</td>
          <td>17.2%</td>
          <td>31 Dec 2024</td>
          <td>Official estimate[5]</td>
          <td>[c]</td>
        </tr>
        <tr>
          <th>3</th>
          <td>United States</td>
          <td>340110988</td>
          <td>4.2%</td>
          <td>1 Jul 2024</td>
          <td>Official estimate[6]</td>
          <td>[d]</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Indonesia</td>
          <td>282477584</td>
          <td>3.5%</td>
          <td>30 Jun 2024</td>
          <td>National annual projection[7]</td>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    </div>



Cuando se pone difícil
----------------------

En muchas situaciones los archivos pueden tener datos estructurados de
alguna manera que no permiten directamente su lectura con ``pandas``.

.. code:: python

    smn_path = Path.cwd().parent / 'data' / 'smn'

.. code:: python

    pronostico = pd.read_csv(smn_path / 'pronostico_header4.txt')
    pronostico




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>************************************************************************************************</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Producto basado en un modelo de pronóstico numérico del tiempo</th>
          <td></td>
        </tr>
        <tr>
          <th>por lo tanto puede diferir del pronostico emitido por el SMN</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>************************************************************************************************</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>AEROPARQUE</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>================================================================================================</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
        </tr>
        <tr>
          <th>06/DIC/2024 12Hs.        13.1       314 |  12         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>06/DIC/2024 15Hs.        16.2       297 |  15         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>06/DIC/2024 18Hs.        15.2       304 |  23         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>06/DIC/2024 21Hs.         9.1       308 |  17         0.0</th>
          <td>NaN</td>
        </tr>
        <tr>
          <th>================================================================================================</th>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    <p>187 rows × 1 columns</p>
    </div>



Probemos usando ``read_fwf``, que es capaz de leer tablas con columnas
de ancho fijo:

.. code:: python

    pronostico = pd.read_fwf(smn_path / 'pronostico_header4.txt',skiprows=5)
    pronostico.head(10)





.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>AEROPARQUE</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>==============================================...</td>
        </tr>
        <tr>
          <th>1</th>
          <td>FECHA *          TEMPERATURA      VIENTO      ...</td>
        </tr>
        <tr>
          <th>2</th>
          <td>(DIR | KM/H)</td>
        </tr>
        <tr>
          <th>3</th>
          <td>==============================================...</td>
        </tr>
        <tr>
          <th>4</th>
          <td>02/DIC/2024 00Hs.        16.0       236 |  17 ...</td>
        </tr>
        <tr>
          <th>5</th>
          <td>02/DIC/2024 03Hs.        14.4       196 |  18 ...</td>
        </tr>
        <tr>
          <th>6</th>
          <td>02/DIC/2024 06Hs.        10.6       190 |   8 ...</td>
        </tr>
        <tr>
          <th>7</th>
          <td>02/DIC/2024 09Hs.        14.9       221 |  11 ...</td>
        </tr>
        <tr>
          <th>8</th>
          <td>02/DIC/2024 12Hs.        19.2       249 |  12 ...</td>
        </tr>
        <tr>
          <th>9</th>
          <td>02/DIC/2024 15Hs.        21.6       241 |  15 ...</td>
        </tr>
      </tbody>
    </table>
    </div>



Como se esperaba, no parece ser la solución porque la estructura del
archivo no es estrictamente de columnas de ancho fijo, sino de secciones
de columnas de ancho fijo. Entonces tenemos que preprocesar el archivo
para llegar a obtener esas secciones:

.. code:: python

    with open(smn_path / 'pronostico_5dias20250408.txt', 'r') as file:
        content = file.read()
    
    # Dividir el contenido en secciones por aeropuerto
    sep =  "================================================================================================"
    sections = content.split(sep)
    for i,s in enumerate(sections[0:5]):
        print(f"Sección {i} {'-'*80}")
        print(f"{s}")


.. parsed-literal::

    Sección 0 --------------------------------------------------------------------------------
    ************************************************************************************************
     Producto basado en un modelo de pronóstico numérico del tiempo, 
     por lo tanto puede diferir del pronostico emitido por el SMN
     ************************************************************************************************
     
     AEROPARQUE
     
    Sección 1 --------------------------------------------------------------------------------
    
          FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)                        
     
    Sección 2 --------------------------------------------------------------------------------
    
      08/ABR/2025 00Hs.        15.4       116 |  27         7.5 
      08/ABR/2025 03Hs.        15.6       112 |  25         3.0 
      08/ABR/2025 06Hs.        16.0       114 |  26         3.0 
      08/ABR/2025 09Hs.        16.3       115 |  26         1.7 
      08/ABR/2025 12Hs.        16.6       123 |  22         1.1 
      08/ABR/2025 15Hs.        17.0       123 |  24         0.9 
      08/ABR/2025 18Hs.        16.7       117 |  24         1.8 
      08/ABR/2025 21Hs.        16.6       104 |  22         1.4 
      09/ABR/2025 00Hs.        16.7       100 |  22         0.6 
      09/ABR/2025 03Hs.        16.2       110 |  21         1.2 
      09/ABR/2025 06Hs.        16.0       107 |  18         1.3 
      09/ABR/2025 09Hs.        16.1        99 |  18         1.9 
      09/ABR/2025 12Hs.        17.3        99 |  14         0.7 
      09/ABR/2025 15Hs.        19.9       106 |  19         0.4 
      09/ABR/2025 18Hs.        18.2       104 |  17         0.0 
      09/ABR/2025 21Hs.        17.1       108 |  16         0.0 
      10/ABR/2025 00Hs.        17.1       109 |  15         0.0 
      10/ABR/2025 03Hs.        17.6       104 |  16         0.0 
      10/ABR/2025 06Hs.        17.0        94 |  13         0.0 
      10/ABR/2025 09Hs.        18.2        98 |  13         0.0 
      10/ABR/2025 12Hs.        19.7       102 |  11         0.1 
      10/ABR/2025 15Hs.        21.3       138 |  12         0.0 
      10/ABR/2025 18Hs.        19.5       120 |  14         0.0 
      10/ABR/2025 21Hs.        18.6       109 |   8         0.2 
      11/ABR/2025 00Hs.        17.2        22 |   4         0.0 
      11/ABR/2025 03Hs.        14.8        35 |   6         0.0 
      11/ABR/2025 06Hs.        15.2        26 |   4         0.0 
      11/ABR/2025 09Hs.        17.5        30 |   2         0.0 
      11/ABR/2025 12Hs.        19.6         6 |   3         0.2 
      11/ABR/2025 15Hs.        22.8       326 |   3         0.0 
      11/ABR/2025 18Hs.        20.1       187 |   4         0.0 
      11/ABR/2025 21Hs.        18.2       115 |   3         0.0 
      12/ABR/2025 00Hs.        16.6       292 |   3         0.0 
      12/ABR/2025 03Hs.        15.1       254 |   6         0.0 
      12/ABR/2025 06Hs.        14.4       239 |   6         0.0 
      12/ABR/2025 09Hs.        17.6       213 |   6         0.0 
      12/ABR/2025 12Hs.        22.4       149 |   7         0.0 
      12/ABR/2025 15Hs.        22.8       123 |   8         0.0 
      12/ABR/2025 18Hs.        19.5        72 |   4         0.0 
      12/ABR/2025 21Hs.        17.0        95 |   8         0.0 
     
    Sección 3 --------------------------------------------------------------------------------
    
     AZUL_AERO
     
    Sección 4 --------------------------------------------------------------------------------
    
          FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)                        
     


.. code:: python

    print("Estación : ", sections[0])
    print("Header : ", sections[1])
    print("Pronóstico : ", sections[2])



.. parsed-literal::

    Estación :  ************************************************************************************************
     Producto basado en un modelo de pronóstico numérico del tiempo, 
     por lo tanto puede diferir del pronostico emitido por el SMN
     ************************************************************************************************
     
     AEROPARQUE
     
    Header :  
          FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)                        
     
    Pronóstico :  
      08/ABR/2025 00Hs.        15.4       116 |  27         7.5 
      08/ABR/2025 03Hs.        15.6       112 |  25         3.0 
      08/ABR/2025 06Hs.        16.0       114 |  26         3.0 
      08/ABR/2025 09Hs.        16.3       115 |  26         1.7 
      08/ABR/2025 12Hs.        16.6       123 |  22         1.1 
      08/ABR/2025 15Hs.        17.0       123 |  24         0.9 
      08/ABR/2025 18Hs.        16.7       117 |  24         1.8 
      08/ABR/2025 21Hs.        16.6       104 |  22         1.4 
      09/ABR/2025 00Hs.        16.7       100 |  22         0.6 
      09/ABR/2025 03Hs.        16.2       110 |  21         1.2 
      09/ABR/2025 06Hs.        16.0       107 |  18         1.3 
      09/ABR/2025 09Hs.        16.1        99 |  18         1.9 
      09/ABR/2025 12Hs.        17.3        99 |  14         0.7 
      09/ABR/2025 15Hs.        19.9       106 |  19         0.4 
      09/ABR/2025 18Hs.        18.2       104 |  17         0.0 
      09/ABR/2025 21Hs.        17.1       108 |  16         0.0 
      10/ABR/2025 00Hs.        17.1       109 |  15         0.0 
      10/ABR/2025 03Hs.        17.6       104 |  16         0.0 
      10/ABR/2025 06Hs.        17.0        94 |  13         0.0 
      10/ABR/2025 09Hs.        18.2        98 |  13         0.0 
      10/ABR/2025 12Hs.        19.7       102 |  11         0.1 
      10/ABR/2025 15Hs.        21.3       138 |  12         0.0 
      10/ABR/2025 18Hs.        19.5       120 |  14         0.0 
      10/ABR/2025 21Hs.        18.6       109 |   8         0.2 
      11/ABR/2025 00Hs.        17.2        22 |   4         0.0 
      11/ABR/2025 03Hs.        14.8        35 |   6         0.0 
      11/ABR/2025 06Hs.        15.2        26 |   4         0.0 
      11/ABR/2025 09Hs.        17.5        30 |   2         0.0 
      11/ABR/2025 12Hs.        19.6         6 |   3         0.2 
      11/ABR/2025 15Hs.        22.8       326 |   3         0.0 
      11/ABR/2025 18Hs.        20.1       187 |   4         0.0 
      11/ABR/2025 21Hs.        18.2       115 |   3         0.0 
      12/ABR/2025 00Hs.        16.6       292 |   3         0.0 
      12/ABR/2025 03Hs.        15.1       254 |   6         0.0 
      12/ABR/2025 06Hs.        14.4       239 |   6         0.0 
      12/ABR/2025 09Hs.        17.6       213 |   6         0.0 
      12/ABR/2025 12Hs.        22.4       149 |   7         0.0 
      12/ABR/2025 15Hs.        22.8       123 |   8         0.0 
      12/ABR/2025 18Hs.        19.5        72 |   4         0.0 
      12/ABR/2025 21Hs.        17.0        95 |   8         0.0 
     


La lista ``sections`` contiene secciones que corresponden a una estación
meteorológica, cuyos nombres son:

.. code:: python

    print(sections[0].split('\n')[-2].strip()) # tratamiento especial para remover el comentario
    print(sections[3].strip())
    print(sections[6].strip())


.. parsed-literal::

    AEROPARQUE
    AZUL_AERO
    BAHIA_BLANCA_AERO


   La primer sección debe trabajarse a mano debido al comentario que
   posee el archivo

Las siguientes serían las secciones de headers que en principio no nos
harían falta:

.. code:: python

    print(sections[1].strip())
    print(sections[4].strip())
    print(sections[7].strip())


.. parsed-literal::

    FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)
    FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)
    FECHA *          TEMPERATURA      VIENTO      PRECIPITACION(mm)
                                         (DIR | KM/H)


Finalmente tenemos las secciones con los datos:

.. code:: python

    print(sections[2].split('\n')[:5])
    print(sections[5].split('\n')[:5])
    print(sections[8].split('\n')[:5])


.. parsed-literal::

    ['', '  08/ABR/2025 00Hs.        15.4       116 |  27         7.5 ', '  08/ABR/2025 03Hs.        15.6       112 |  25         3.0 ', '  08/ABR/2025 06Hs.        16.0       114 |  26         3.0 ', '  08/ABR/2025 09Hs.        16.3       115 |  26         1.7 ']
    ['', '  08/ABR/2025 00Hs.        10.3       109 |  15         0.0 ', '  08/ABR/2025 03Hs.         9.3       124 |  12         0.0 ', '  08/ABR/2025 06Hs.         8.9       134 |  11         0.0 ', '  08/ABR/2025 09Hs.        12.6       122 |  18         0.0 ']
    ['', '  08/ABR/2025 00Hs.        13.5        35 |  20         0.0 ', '  08/ABR/2025 03Hs.        11.7        31 |  16         0.0 ', '  08/ABR/2025 06Hs.        10.7        42 |  12         0.0 ', '  08/ABR/2025 09Hs.        12.6        50 |  15         0.0 ']


Ahora sí podemos usar ``read_fwf`` para transformar las secciones en
``DataFrame``\ s. Para ello tenemos que convertir cada ``section`` (que
es un string) en un tipo de buffer en memoria que se comporte como un
archivo. Obsérvese que si hacemos:

.. code:: python

    from io import StringIO 
    
    with StringIO(sections[5]) as data_io:
        df_malo = pd.read_fwf(data_io)
        
    df_malo.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>08/ABR/2025</th>
          <th>00Hs.</th>
          <th>10.3</th>
          <th>109</th>
          <th>|</th>
          <th>15</th>
          <th>0.0</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>9.3</td>
          <td>124</td>
          <td>|</td>
          <td>12</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>8.9</td>
          <td>134</td>
          <td>|</td>
          <td>11</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>12.6</td>
          <td>122</td>
          <td>|</td>
          <td>18</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>19.4</td>
          <td>95</td>
          <td>|</td>
          <td>22</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>15Hs.</td>
          <td>21.4</td>
          <td>99</td>
          <td>|</td>
          <td>28</td>
          <td>0.0</td>
        </tr>
      </tbody>
    </table>
    </div>



Es decir que la primer fila del *stream* es tomada como los nombres de
las columnas. Tenemos que pasar el argumento opcional ``names`` para
definir los nombres de las columnas:

.. code:: python

    with StringIO(sections[2]) as data_io:
        df = pd.read_fwf(data_io,names=['fecha','h','t','v_dir','l','v_vel','precip'])
        
    df.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>fecha</th>
          <th>h</th>
          <th>t</th>
          <th>v_dir</th>
          <th>l</th>
          <th>v_vel</th>
          <th>precip</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>00Hs.</td>
          <td>15.4</td>
          <td>116</td>
          <td>|</td>
          <td>27</td>
          <td>7.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>15.6</td>
          <td>112</td>
          <td>|</td>
          <td>25</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>16.0</td>
          <td>114</td>
          <td>|</td>
          <td>26</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>16.3</td>
          <td>115</td>
          <td>|</td>
          <td>26</td>
          <td>1.7</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>16.6</td>
          <td>123</td>
          <td>|</td>
          <td>22</td>
          <td>1.1</td>
        </tr>
      </tbody>
    </table>
    </div>



   Si el archivo no contiene headers, y se desea que se generen
   automáticamente como una secuencia numérica (0, 1, 2, …), se puede
   usar la opción ``header=None`` en cualquiera de los métodos ``read_``
   de pandas.

.. code:: python

    with StringIO(sections[2]) as data_io:
        df_auto = pd.read_fwf(data_io,header=None)
        
    df_auto.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>00Hs.</td>
          <td>15.4</td>
          <td>116</td>
          <td>|</td>
          <td>27</td>
          <td>7.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>15.6</td>
          <td>112</td>
          <td>|</td>
          <td>25</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>16.0</td>
          <td>114</td>
          <td>|</td>
          <td>26</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>16.3</td>
          <td>115</td>
          <td>|</td>
          <td>26</td>
          <td>1.7</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>16.6</td>
          <td>123</td>
          <td>|</td>
          <td>22</td>
          <td>1.1</td>
        </tr>
      </tbody>
    </table>
    </div>



Para terminar podemos eliminar la columna ``l`` que no aporta
información:

.. code:: python

    df.drop(columns=['l'],inplace=True)
    df.head()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>fecha</th>
          <th>h</th>
          <th>t</th>
          <th>v_dir</th>
          <th>v_vel</th>
          <th>precip</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>08/ABR/2025</td>
          <td>00Hs.</td>
          <td>15.4</td>
          <td>116</td>
          <td>27</td>
          <td>7.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>08/ABR/2025</td>
          <td>03Hs.</td>
          <td>15.6</td>
          <td>112</td>
          <td>25</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>08/ABR/2025</td>
          <td>06Hs.</td>
          <td>16.0</td>
          <td>114</td>
          <td>26</td>
          <td>3.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>08/ABR/2025</td>
          <td>09Hs.</td>
          <td>16.3</td>
          <td>115</td>
          <td>26</td>
          <td>1.7</td>
        </tr>
        <tr>
          <th>4</th>
          <td>08/ABR/2025</td>
          <td>12Hs.</td>
          <td>16.6</td>
          <td>123</td>
          <td>22</td>
          <td>1.1</td>
        </tr>
      </tbody>
    </table>
    </div>



--------------

Ejercicios 14 (a)
=================

1. Complete la tabla de datos del ejemplo de clase. Para ello utilice el
   archivo con los pronósticos completos para todas las estaciones,
   ``pronostico_5dias20250408.txt`` y

-  Agregue una columna con el nombre de la estación al DataFrame
-  Procese todas las estaciones

--------------



Estructuras de datos en ``pandas``: Series
==========================================

Las series son un objeto unidimensional que contiene una secuencia de
valores *del mismo tipo* y un conjunto de etiquetas denominado *índice*:

.. code:: python

    import numpy as np
    import pandas as pd 

.. code:: python

    s = pd.Series([1,4,4,2])
    print(s)
    print(type(s))
    print(s.dtype)


.. parsed-literal::

    0    1
    1    4
    2    4
    3    2
    dtype: int64
    <class 'pandas.core.series.Series'>
    int64


En este ejemplo, ``s`` es una serie que contiene elementos ``int64``.

   Los tipos de datos son extensiones de aquellos que utiliza ``numpy``.

..

   Notar que usando directamente la función ``print`` obtenemos una
   representación textual de la serie.

Se puede acceder a los valores de la serie con el método ``.array``, y a
los índices con el método ``.index``:

.. code:: python

    s.array




.. parsed-literal::

    <NumpyExtensionArray>
    [1, 4, 4, 2]
    Length: 4, dtype: int64



El tipo ``NumpyExtensionArray`` es una clase que encapsula al tipo array
de ``numpy``, pero ha permitido agregarle flexibilidad para acomodar las
características de datos más generales.

Por otra parte, los índices se obtienen como:

.. code:: python

    s.index 




.. parsed-literal::

    RangeIndex(start=0, stop=4, step=1)



Los índices son inmutables, en el mismo sentido que los caracteres de un
string. Es decir, no se pueden cambiar ciertos índices, pero se puede
*reasignar* el índice de una serie completamente:

.. code:: python

    print(s.index[2])
    s.index[2] = 5


.. parsed-literal::

    2


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[5], line 2
          1 print(s.index[2])
    ----> 2 s.index[2] = 5


    File /usr/lib64/python3.13/site-packages/pandas/core/indexes/base.py:5371, in Index.__setitem__(self, key, value)
       5369 @final
       5370 def __setitem__(self, key, value) -> None:
    -> 5371     raise TypeError("Index does not support mutable operations")


    TypeError: Index does not support mutable operations


.. code:: python

    nuevo_index = index=['a','b','c','d']
    s.index = nuevo_index
    print(s)


.. parsed-literal::

    a    1
    b    4
    c    4
    d    2
    dtype: int64


Se puede también construir una nueva serie indicando los índices
específicamente en el constructor con el argumento ``index=``:

.. code:: python

    s2 = pd.Series([1,4,4,2], index=['arquero','defensores','medios','delanteros'])
    print(s2)


.. parsed-literal::

    arquero       1
    defensores    4
    medios        4
    delanteros    2
    dtype: int64


Existen otras maneras de crear series en ``pandas``, como por ejemplo a
partir de arreglos de ``numpy``

.. code:: python

    rnd = pd.Series(np.random.randn(5))
    print(rnd)


.. parsed-literal::

    0    0.370947
    1    1.600918
    2    0.161127
    3   -0.929294
    4   -0.121632
    dtype: float64


A partir de otras variables

.. code:: python

    values = [1,2,3,4,5]
    index = ['a','b','c','d','e']
    s3 = pd.Series(values, index=index)
    s3




.. parsed-literal::

    a    1
    b    2
    c    3
    d    4
    e    5
    dtype: int64



o usando diccionarios:

.. code:: python

    d = { 1: "a", 2: "b", 3: "c", 4: "d", 5: "e" }
    s4 = pd.Series(d,dtype='string')
    print(s4)


.. parsed-literal::

    1    a
    2    b
    3    c
    4    d
    5    e
    dtype: string


Asimismo, se puede usar el argumento ``dtype`` (igual que en NumPy) para
indicar el tipo de dato que se quiere utilizar al crear la serie. Pandas
soporta los tipos de datos de NumPy, además de proveer sus propios tipos
de datos (por ejemplo, ``string``) propios

.. code:: python

    n = pd.Series([4,5,6], dtype='string')
    print(n)
    print(n[0]+n[1])


.. parsed-literal::

    0    4
    1    5
    2    6
    dtype: string
    45


Accediendo a los valores
------------------------

Se puede acceder a los valores de una serie a través del índice como si
fuera un array:

.. code:: python

    s = pd.Series([ 4, 8, 15, 16, 23, 42 ],index = ['a','b','c','d','e','f'])
    print(s)


.. parsed-literal::

    a     4
    b     8
    c    15
    d    16
    e    23
    f    42
    dtype: int64


.. code:: python

    print(f"Tercer elemento: {s.array[2]}")
    s.array[2] = 108
    print(s.array)
    
    print(f"Con un rango:\n{s[1:3]}")
    print(f"Con los índices:\n{s[['a','c']]}")
    print(f"Con una máscara:\n{s[s > 100]}")


.. parsed-literal::

    Tercer elemento: 15
    <NumpyExtensionArray>
    [4, 8, 108, 16, 23, 42]
    Length: 6, dtype: int64
    Con un rango:
    b      8
    c    108
    dtype: int64
    Con los índices:
    a      4
    c    108
    dtype: int64
    Con una máscara:
    c    108
    dtype: int64


.. code:: python

    print(f"Con una lista de índices:\n{s[[0,1]]}")


.. parsed-literal::

    Con una lista de índices:
    a    4
    b    8
    dtype: int64


.. parsed-literal::

    /tmp/ipykernel_213536/1722261588.py:1: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
      print(f"Con una lista de índices:\n{s[[0,1]]}")


.. code:: python

    print(f"Con una lista de índices:\n{s.iloc[[0,3]]}") 
    print(f"Con una lista de índices:\n{s[ s.index[[0,3]] ]}")


.. parsed-literal::

    Con una lista de índices:
    a     4
    d    16
    dtype: int64
    Con una lista de índices:
    a     4
    d    16
    dtype: int64


Modificando valores
-------------------

Para modificar un valor dentro de una serie de ``pandas``, se accede al
mismo con la etiqueta correspondiente:

.. code:: python

    v = pd.Series([1,2,3,4,5], index=['a','b','c','d','e'])
    print(v)
    v['b'] = 100
    print(v)


.. parsed-literal::

    a    1
    b    2
    c    3
    d    4
    e    5
    dtype: int64
    a      1
    b    100
    c      3
    d      4
    e      5
    dtype: int64


En caso en que dicha etiqueta no exista dentro del índice de la serie,
se agrega el valor:

.. code:: python

    v['f'] = 200
    print(v)


.. parsed-literal::

    a      1
    b    100
    c      3
    d      4
    e      5
    f    200
    dtype: int64


Para eliminar valores, se utiliza el método ``.drop``. Por defecto se
genera una nueva serie con el valor eliminado, para poder eliminar el
valor en la misma serie, es necesario usar el argumento opcional
``inplace`` como ``True``.

.. code:: python

    w = v.drop('b')
    print(v)
    print(w)


.. parsed-literal::

    a      1
    b    100
    c      3
    d      4
    e      5
    f    200
    dtype: int64
    a      1
    c      3
    d      4
    e      5
    f    200
    dtype: int64


.. code:: python

    v.drop('b', inplace=True)
    print(v)


.. parsed-literal::

    a      1
    c      3
    d      4
    e      5
    f    200
    dtype: int64


.. code:: python

    # Generando un nuevo objeto
    print(v==w)
    # Comparando objetos
    print(f"v is w: {v is w}")
    print(f"v equals w: {v.equals(w)}")


.. parsed-literal::

    a    True
    c    True
    d    True
    e    True
    f    True
    dtype: bool
    v is w: False
    v equals w: True


.. code:: python

    v.drop(['b'], inplace=True) # KeyError: "['b'] not found in axis"


::


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    Cell In[21], line 1
    ----> 1 v.drop(['b'], inplace=True) # KeyError: "['b'] not found in axis"


    File /usr/lib64/python3.13/site-packages/pandas/core/series.py:5347, in Series.drop(self, labels, axis, index, columns, level, inplace, errors)
       5250 def drop(
       5251     self,
       5252     labels: IndexLabel | None = None,
       (...)
       5259     errors: IgnoreRaise = "raise",
       5260 ) -> Series | None:
       5261     """
       5262     Return Series with specified index labels removed.
       5263 
       (...)
       5345     dtype: float64
       5346     """
    -> 5347     return super().drop(
       5348         labels=labels,
       5349         axis=axis,
       5350         index=index,
       5351         columns=columns,
       5352         level=level,
       5353         inplace=inplace,
       5354         errors=errors,
       5355     )


    File /usr/lib64/python3.13/site-packages/pandas/core/generic.py:4785, in NDFrame.drop(self, labels, axis, index, columns, level, inplace, errors)
       4783 for axis, labels in axes.items():
       4784     if labels is not None:
    -> 4785         obj = obj._drop_axis(labels, axis, level=level, errors=errors)
       4787 if inplace:
       4788     self._update_inplace(obj)


    File /usr/lib64/python3.13/site-packages/pandas/core/generic.py:4827, in NDFrame._drop_axis(self, labels, axis, level, errors, only_slice)
       4825         new_axis = axis.drop(labels, level=level, errors=errors)
       4826     else:
    -> 4827         new_axis = axis.drop(labels, errors=errors)
       4828     indexer = axis.get_indexer(new_axis)
       4830 # Case for non-unique axis
       4831 else:


    File /usr/lib64/python3.13/site-packages/pandas/core/indexes/base.py:7070, in Index.drop(self, labels, errors)
       7068 if mask.any():
       7069     if errors != "ignore":
    -> 7070         raise KeyError(f"{labels[mask].tolist()} not found in axis")
       7071     indexer = indexer[~mask]
       7072 return self.delete(indexer)


    KeyError: "['b'] not found in axis"


Tipos de datos
~~~~~~~~~~~~~~

Como último comentario, obsérvese que si uno pretende crear una serie
con valores de distinto tipo, el tipo de la serie se promueve al tipo
general ``object``, sin embargo cada elemento es reconocido con su tipo
particular:

.. code:: python

    s = pd.Series([1,'a','b','c'])
    print(s)
    for index,elem in s.items(): 
        print(f"Tipo de objeto del elemento {index}: {type(s[index])}")


.. parsed-literal::

    0    1
    1    a
    2    b
    3    c
    dtype: object
    Tipo de objeto del elemento 0: <class 'int'>
    Tipo de objeto del elemento 1: <class 'str'>
    Tipo de objeto del elemento 2: <class 'str'>
    Tipo de objeto del elemento 3: <class 'str'>


.. code:: python

    print(f"Suma de enteros: {s[0] + 3}")
    print(f"Suma de enteros: {s[1] + 3}") # Error


.. parsed-literal::

    Suma de enteros: 4


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[23], line 2
          1 print(f"Suma de enteros: {s[0] + 3}")
    ----> 2 print(f"Suma de enteros: {s[1] + 3}") # Error


    TypeError: can only concatenate str (not "int") to str


.. code:: python

    print(f"Concat de str  : {s[1] + 'd'}")
    print(f"Concat de str  : {s[1] + 3}") # Error


.. parsed-literal::

    Concat de str  : ad


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[24], line 2
          1 print(f"Concat de str  : {s[1] + 'd'}")
    ----> 2 print(f"Concat de str  : {s[1] + 3}") # Error


    TypeError: can only concatenate str (not "int") to str


Si bien entonces se pueden usar series con objetos con distintos tipos,
se recomienda que el tipo de dato sea homogéneo.

Valores que faltan
------------------

Es muy común al procesar datos que uno encuentre valores que no existen.
La manera en que ``pandas`` representa estos datos faltantes es a través
de ``np.nan``, el tipo de dato de ``numpy`` que representa *not a
number*, para aquellos tipos de datos heredados de ``numpy``:

.. code:: python

    snan = pd.Series([1,4,np.nan,2])
    print(snan)


.. parsed-literal::

    0    1.0
    1    4.0
    2    NaN
    3    2.0
    dtype: float64


   Notar que si bien los datos existentes son de tipo entero, al
   utilizar ``np.nan`` para representar un dato inexistente, el tipo de
   dato de la serie se promueve a ``float64``.

De la misma forma, se puede usar ``None`` para representar el dato
faltante:

.. code:: python

    snone = pd.Series([1,4,None,5])
    print(snone)


.. parsed-literal::

    0    1.0
    1    4.0
    2    NaN
    3    5.0
    dtype: float64


En el caso de cadenas de caracteres, se puede usar ``np.nan`` o
``None``. Si no se indica el tipo de dato a través de ``dtype``, se
promueve el tipo de dato de la serie a ``object``, como sucede por
defecto.

.. code:: python

    smixed_str = pd.Series(['a','b',np.nan,None,'d'])
    smixed_str




.. parsed-literal::

    0       a
    1       b
    2     NaN
    3    None
    4       d
    dtype: object



Esto tiene el inconveniente evidente de que el elemento faltante no está
representado unívocamente por un solo valor. Para solventar este
problema, se puede crear la serie con el tipo ``string``:

.. code:: python

    smixed_str2 = pd.Series(['a','b',np.nan,None,'d'],dtype='string')
    print(smixed_str2)


.. parsed-literal::

    0       a
    1       b
    2    <NA>
    3    <NA>
    4       d
    dtype: string


En este caso, el singlete ``NA`` representa unívocamente el dato
faltante. En cualquier caso, se cuenta con el método ``.isna``, que
retorna una serie de ``boolean`` donde los valores faltantes son
verdaderos (``True``):

.. code:: python

    print(smixed_str.isna())
    print(smixed_str2.isna())


.. parsed-literal::

    0    False
    1    False
    2     True
    3     True
    4    False
    dtype: bool
    0    False
    1    False
    2     True
    3     True
    4    False
    dtype: bool


   Atención, la cadena de caracteres vacía ``''`` *NO* se considera un
   dato inexistente.

Puede ser útil en algunos casos poder filtrar los datos inexistentes.
Para eso se utiliza el método ``.dropna``, que crea una nueva serie sin
dichos datos:

.. code:: python

    print(smixed_str)
    print(smixed_str.dropna())


.. parsed-literal::

    0       a
    1       b
    2     NaN
    3    None
    4       d
    dtype: object
    0    a
    1    b
    4    d
    dtype: object


Operando con series
-------------------

Las operaciones con series han sido diseñadas para que sean compatibles
con NumPy, y sigan las convenciones de Python. He aquí algunos ejemplos:

.. code:: python

    ones = pd.Series(np.ones(8))*0.5
    print(ones)
    
    t = pd.Series(np.random.rand(8))
    print(t)
    print(t.mean())


.. parsed-literal::

    0    0.5
    1    0.5
    2    0.5
    3    0.5
    4    0.5
    5    0.5
    6    0.5
    7    0.5
    dtype: float64
    0    0.855919
    1    0.316680
    2    0.188950
    3    0.535831
    4    0.767803
    5    0.836171
    6    0.225345
    7    0.559054
    dtype: float64
    0.5357193052760575


.. code:: python

    shifted = t - ones 
    print(shifted)
    print(shifted.mean())
    print(np.abs(shifted))


.. parsed-literal::

    0    0.355919
    1   -0.183320
    2   -0.311050
    3    0.035831
    4    0.267803
    5    0.336171
    6   -0.274655
    7    0.059054
    dtype: float64
    0.0357193052760575
    0    0.355919
    1    0.183320
    2    0.311050
    3    0.035831
    4    0.267803
    5    0.336171
    6    0.274655
    7    0.059054
    dtype: float64


Además de poder interactuar con NumPy en forma transparente, existen
algunos métodos útiles para trabajar con los datos de una serie:

.. code:: python

    data = {'Pedro':19, 'Oscar': 30, 'Carlos': 27, 'David': 26}
    seru = pd.Series(data)
    print("Person Series:\n")
    print(seru)
    
    # Perform operations on the Series
    print("Edad promedio:", seru.mean())
    print("Edad del más viejo :", seru.max())
    print("El más viejo :", seru.idxmax())


.. parsed-literal::

    Person Series:
    
    Pedro     19
    Oscar     30
    Carlos    27
    David     26
    dtype: int64
    Edad promedio: 25.5
    Edad del más viejo : 30
    El más viejo : Oscar


.. code:: python

    temperaturas_ciudades = {
        "Buenos Aires": 17.6,
        "Córdoba": 18.0,
        "Rosario": 18.0,
        "Mendoza": 16.0,
        "Santa Fe": 21.3
    
    }
    temp = pd.Series(temperaturas_ciudades)
    print(temp)


.. parsed-literal::

    Buenos Aires    17.6
    Córdoba         18.0
    Rosario         18.0
    Mendoza         16.0
    Santa Fe        21.3
    dtype: float64


.. code:: python

    otras_ciudades = ['Buenos Aires', 'Córdoba', 'Rosario', 'Mendoza', 'Salta']
    temp = pd.Series(temperaturas_ciudades, index=otras_ciudades)
    print(temp)


.. parsed-literal::

    Buenos Aires    17.6
    Córdoba         18.0
    Rosario         18.0
    Mendoza         16.0
    Salta            NaN
    dtype: float64


.. code:: python

    temp_ciudades2 = {
        "Mendoza": 20.0,
        "Salta": 17.2,
        "Santa Fe": 18.6,
        "San Juan": 19.3
    }
    temp2 = pd.Series(temp_ciudades2)
    temp2




.. parsed-literal::

    Mendoza     20.0
    Salta       17.2
    Santa Fe    18.6
    San Juan    19.3
    dtype: float64



.. code:: python

    print(temp)


.. parsed-literal::

    Buenos Aires    17.6
    Córdoba         18.0
    Rosario         18.0
    Mendoza         16.0
    Salta            NaN
    dtype: float64


.. code:: python

    print((temp + temp2)/2)


.. parsed-literal::

    Buenos Aires     NaN
    Córdoba          NaN
    Mendoza         18.0
    Rosario          NaN
    Salta            NaN
    San Juan         NaN
    Santa Fe         NaN
    dtype: float64


Misceláneas
-----------

Algunas otras operaciones interesantes:

.. code:: python

    'Rosario' in temp2




.. parsed-literal::

    False



.. code:: python

    temp2_dict = temp2.to_dict()
    print(temp2_dict)
    print(type(temp2_dict))


.. parsed-literal::

    {'Mendoza': 20.0, 'Salta': 17.2, 'Santa Fe': 18.6, 'San Juan': 19.3}
    <class 'dict'>


.. code:: python

    temp2_json = temp2.to_json() 
    print(temp2_json)
    print(type(temp2_json))


.. parsed-literal::

    {"Mendoza":20.0,"Salta":17.2,"Santa Fe":18.6,"San Juan":19.3}
    <class 'str'>


--------------

Ejercicios 14(b)
================

2. Si no lo ha adivinado, los datos de la serie ``seru`` corresponden a
   las edades de los integrantes de la banda Serú Girán, al momento de
   conformarse, en el año 1978. Encuentre los años de nacimiento de cada
   uno de sus integrantes.

3. Una de las funciones más usadas en redes neuronales es *softmax*,
   cuyo objetivo es convertir los resultados de las distintas etapas del
   procesamiento de una red en probabilidades. Los primeros pueden ser
   números reales de cualquier valor, mientras que las probabilidades
   deben estar acotadas al intervalo [0,1]. La función *softmax*
   aplicada a un conjunto de valores :math:`z_1,\cdots,z_n` se calcula
   como

   .. math::


      \sigma(z_i) = \frac {e^{z_i}} { \sum_{i=1}^n e^{z_i}}

   -  Cree una serie con 10 valores al azar entre 0 y 5
   -  Obtenga la serie resultante de la aplicación de *softmax* a la
      serie anterior

4. El siguiente es un diccionario que representa el consumo eléctrico
   mensual de ciertos artefactos eléctricos:

   .. code:: python

      consumo_electrico = {
        "Artefacto": [
           "Heladera", "Lavarropa", "Microondas", "Aire Acondicionado", 
           "Televisor", "Computadora", "Lámpara LED", "Secador de Pelo", 
           "Horno Eléctrico", "Ventilador"
        ],
        "Consumo Promedio (kWh/mes)": [
           30, 10, 15, 120, 20, 12, 2, 3, 25, 8
        ]
      }

   -  Obtenga los tres artefactos de mayor consumo.
   -  Encuentre los artefactos que consumen más de 15 kWH/mes.
   -  Calcule el consumo anual de cada artefacto, y el costo que implica
      suponiendo que el precio del kWH/mes es de $3145.

5. Un problema de índices enteros. Supongamos que tenemos la serie

   .. code:: python

      s = pd.Series(np.arange(3.0))

   es decir,

   .. code:: python

       0    0.0
       1    1.0
       2    2.0
       dtype: float64

   ¿Cuál es el resultado esperado de s[-1]? ¿Cuál es el real? Evalúe
   ``s[-2:-1]`` y también ``s.iloc[-1]``. Considere ahora la serie

   .. code:: python

      s = pd.Series(np.arange(3.0), index=['a','b','c'])

   y evalúe nuevamente ``s[-1]``. ¿Qué conclusiones puede sacar?

--------------

Estructuras de datos en ``pandas``: ``DataFrame``\ s
====================================================

Hemos visto que una serie en ``pandas`` es representa una colección de
valores indexados por sendas etiquetas. La extensión natural (?) de una
serie es una colección con múltiples valores arreglados en columnas
indexados por una misma colección de etiquetas. Es decir, una tabla… La
estructura que representa tablas en ``pandas`` se llama *DataFrame*. Un
``DataFrame`` tiene un índice de filas (como las series) y un índice de
columnas.

   Se puede pensar un ``DataFrame`` como un diccionario de series que
   comparten un mismo índice.

Como las series, es habitual construir un ``DataFrame`` a partir de un
diccionario. Veamos el siguiente diccionario para comenzar a trabajar.
Como siempre, importamos los módulos indispensables:

.. code:: python

    import numpy as np
    import pandas as pd

.. code:: python

    data = {
        "Titulo": [
            "La piedra filosofal",
            "La cámara secreta",
            "El prisionero de Azkaban",
            "El cáliz de fuego",
            "La orden del Fénix",
            "El misterio del príncipe",
            "Las reliquias de la muerte"
        ],
        "Año de edición": [1997, 1998, 1999, 2000, 2003, 2005, 2007],
        "Páginas": [223, 251, 317, 636, 766, 607, 607],
    }
    
    df = pd.DataFrame(data)
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
        </tr>
      </tbody>
    </table>
    </div>



El diccionario de origen asigna a cada clave una lista de elementos.
Hemos generado un ``DataFrame`` a partir de un diccionario: los índices
de filas se generan automáticamente, mientras que los índices (o
etiquetas) de las columnas corresponden a las claves de cada una de las
listas del diccionario.

   Si las listas que componen el diccionario de origen no son iguales,
   ``pd.DataFrame`` dará un error
   ``ValueError: All arrays must be of the same length``.

Una conveniencia interesante en Jupyter Notebooks es que se puede
imprimir la tabla en forma elegante:

.. code:: python

    print(df) 
    display(df)
    df # también funciona 


.. parsed-literal::

                           Titulo  Año de edición  Páginas
    0         La piedra filosofal            1997      223
    1           La cámara secreta            1998      251
    2    El prisionero de Azkaban            1999      317
    3           El cáliz de fuego            2000      636
    4          La orden del Fénix            2003      766
    5    El misterio del príncipe            2005      607
    6  Las reliquias de la muerte            2007      607



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
        </tr>
      </tbody>
    </table>
    </div>




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
        </tr>
      </tbody>
    </table>
    </div>



Eventualmente uno podría querer ver sólo algunas filas:

.. code:: python

    display(df.head()) # muestra las primeras 5 filas
    display(df.tail()) # muestra las últimas 5 filas



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
        </tr>
      </tbody>
    </table>
    </div>



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
        </tr>
      </tbody>
    </table>
    </div>


El ``DataFrame`` usa la variable ``index`` como en las series, y la
variable ``columns`` para describir las etiquetas de las columnas. Por
ejemplo:

.. code:: python

    df2 = pd.DataFrame(data, index = ["a", "b", "c", "d", "e", "f", "g"], columns = ["Titulo", "Páginas", "Año de edición"])
    df2




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Páginas</th>
          <th>Año de edición</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>La piedra filosofal</td>
          <td>223</td>
          <td>1997</td>
        </tr>
        <tr>
          <th>b</th>
          <td>La cámara secreta</td>
          <td>251</td>
          <td>1998</td>
        </tr>
        <tr>
          <th>c</th>
          <td>El prisionero de Azkaban</td>
          <td>317</td>
          <td>1999</td>
        </tr>
        <tr>
          <th>d</th>
          <td>El cáliz de fuego</td>
          <td>636</td>
          <td>2000</td>
        </tr>
        <tr>
          <th>e</th>
          <td>La orden del Fénix</td>
          <td>766</td>
          <td>2003</td>
        </tr>
        <tr>
          <th>f</th>
          <td>El misterio del príncipe</td>
          <td>607</td>
          <td>2005</td>
        </tr>
        <tr>
          <th>g</th>
          <td>Las reliquias de la muerte</td>
          <td>607</td>
          <td>2007</td>
        </tr>
      </tbody>
    </table>
    </div>



Notar que el orden de la lista de etiquetas que se pasa a ``columns`` se
mantiene al crear el ``DataFrame``. La lista que se usa en la creación
de un ``DataFrame`` usando ``columns`` debe contener exactamente los
mismos valores que las claves del diccionario, sino generará una columna
con datos faltantes.

Para acceder a las etiquetas de filas y columnas, usamos los métodos
``.index`` y ``.columns``.

.. code:: python

    print(f"Indices de filas: {df2.index}")
    print(f"Indices de columnas: {df2.columns}")


.. parsed-literal::

    Indices de filas: Index(['a', 'b', 'c', 'd', 'e', 'f', 'g'], dtype='object')
    Indices de columnas: Index(['Titulo', 'Páginas', 'Año de edición'], dtype='object')


Accediendo a los valores
------------------------

Para acceder a las columnas podemos usar:

.. code:: python

    print(f"Valores de las filas: {df2.values}")
    print(f"Valores de las columnas: {type(df2.values)}")    


.. parsed-literal::

    Valores de las filas: [['La piedra filosofal' 223 1997]
     ['La cámara secreta' 251 1998]
     ['El prisionero de Azkaban' 317 1999]
     ['El cáliz de fuego' 636 2000]
     ['La orden del Fénix' 766 2003]
     ['El misterio del príncipe' 607 2005]
     ['Las reliquias de la muerte' 607 2007]]
    Valores de las columnas: <class 'numpy.ndarray'>


El resultado de esta operación nos devuelve un arreglo 2D de NumPy, cuyo
tipo de dato será el mínimo que pueda contener los tipos de datos de las
columnas que lo componen. Por ejemplo, si nuestras columnas tienen datos
en ``float32`` y ``float64``, el tipo del arreglo de NumPy resultante
será ``float64``. En el caso anterior, los tipos de datos de las
columnas son:

.. code:: python

    df2.dtypes




.. parsed-literal::

    Titulo            object
    Páginas            int64
    Año de edición     int64
    dtype: object



Es decir que los datos en ``int64`` de las columnas ``Páginas`` y
``Año de edición`` se promueven a ``object``.

El acceso a ciertas columnas en particular se hace como en los
diccionarios:

.. code:: python

    titulos = df2["Titulo"]
    print("La columna 'Titulo'")
    print(f"{titulos}")
    print(f"Tipo de la columna 'Titulo': {type(titulos)}")
    print(f"Valores de la columna 'Titulo': {titulos.values}")
    print(f"Tipo de la columna 'Titulo' .values: {type(titulos.values)}")


.. parsed-literal::

    La columna 'Titulo'
    a           La piedra filosofal
    b             La cámara secreta
    c      El prisionero de Azkaban
    d             El cáliz de fuego
    e            La orden del Fénix
    f      El misterio del príncipe
    g    Las reliquias de la muerte
    Name: Titulo, dtype: object
    Tipo de la columna 'Titulo': <class 'pandas.core.series.Series'>
    Valores de la columna 'Titulo': ['La piedra filosofal' 'La cámara secreta' 'El prisionero de Azkaban'
     'El cáliz de fuego' 'La orden del Fénix' 'El misterio del príncipe'
     'Las reliquias de la muerte']
    Tipo de la columna 'Titulo' .values: <class 'numpy.ndarray'>


Vemos que una columna en un ``DataFrame`` de ``pandas`` es representada
efectivamente por una serie, de este modo, sus valores (obtenidos
mediante ``.values``) serán un arreglo de NumPy, como vimos antes.

En el caso en que la etiqueta de una columna no contenga espacios, se
puede acceder a la misma con el operador ``.``:

.. code:: python

    df2.Titulo # es lo mismo que df2['Titulo']




.. parsed-literal::

    a           La piedra filosofal
    b             La cámara secreta
    c      El prisionero de Azkaban
    d             El cáliz de fuego
    e            La orden del Fénix
    f      El misterio del príncipe
    g    Las reliquias de la muerte
    Name: Titulo, dtype: object



   Si uno quisiera usar esta propiedad en forma exhaustiva para todas
   las columnas, debería reemplazar las etiquetas de las mismas por
   nombres de variables válidos en Python

.. code:: python

    df2.columns = ["titulo", "paginas", "primer_edicion"]
    df2




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>titulo</th>
          <th>paginas</th>
          <th>primer_edicion</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>La piedra filosofal</td>
          <td>223</td>
          <td>1997</td>
        </tr>
        <tr>
          <th>b</th>
          <td>La cámara secreta</td>
          <td>251</td>
          <td>1998</td>
        </tr>
        <tr>
          <th>c</th>
          <td>El prisionero de Azkaban</td>
          <td>317</td>
          <td>1999</td>
        </tr>
        <tr>
          <th>d</th>
          <td>El cáliz de fuego</td>
          <td>636</td>
          <td>2000</td>
        </tr>
        <tr>
          <th>e</th>
          <td>La orden del Fénix</td>
          <td>766</td>
          <td>2003</td>
        </tr>
        <tr>
          <th>f</th>
          <td>El misterio del príncipe</td>
          <td>607</td>
          <td>2005</td>
        </tr>
        <tr>
          <th>g</th>
          <td>Las reliquias de la muerte</td>
          <td>607</td>
          <td>2007</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df2.primer_edicion




.. parsed-literal::

    a    1997
    b    1998
    c    1999
    d    2000
    e    2003
    f    2005
    g    2007
    Name: primer_edicion, dtype: int64



   En el caso en que uno cree un ``DataFrame`` desde una base de datos,
   una buena práctica es mantener la consistencia entre las etiquetas de
   las columnas del ``DataFrame`` y las de la base de datos.

Se puede acceder a una determinada fila usando las etiquetas través de
``.loc`` o con índices enteros con ``.iloc``:

.. code:: python

    print(f"Primer libro:\n{df2.iloc[0]}")
    print(f"Segundo libro:\n{df2.loc['b']}")
    print(f"Último libro:\n{df2.iloc[-1]}")



.. parsed-literal::

    Primer libro:
    titulo            La piedra filosofal
    paginas                           223
    primer_edicion                   1997
    Name: a, dtype: object
    Segundo libro:
    titulo            La cámara secreta
    paginas                         251
    primer_edicion                 1998
    Name: b, dtype: object
    Último libro:
    titulo            Las reliquias de la muerte
    paginas                                  607
    primer_edicion                          2007
    Name: g, dtype: object


Y se puede acceder a un elemento particular de la tabla:

.. code:: python

    print(f"Título primer libro: {df2.iloc[0].titulo}")
    print(f"Año de edición del segundo libro: {df2.loc['b', 'primer_edicion']}")
    print(f"Año de edición del último libro: {df2.iloc[-1, 2]}")


.. parsed-literal::

    Título primer libro: La piedra filosofal
    Año de edición del segundo libro: 1998
    Año de edición del último libro: 2007


La figura presenta los distintos tipos de acceso a los datos de un
``DataFrame``

.. image:: figuras/loc.png







.. note::
    Si se quisiera acceder solo a ciertas regiones de la tabla,
    se pueden reemplazar los valores individuales por rangos, tal como
    uno haría con NumPy
    
.. code:: python

    df2.loc[['a','d'],["titulo", "paginas"]]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>titulo</th>
          <th>paginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>La piedra filosofal</td>
          <td>223</td>
        </tr>
        <tr>
          <th>d</th>
          <td>El cáliz de fuego</td>
          <td>636</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df2.loc[:'d',["titulo", "primer_edicion"]]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>titulo</th>
          <th>primer_edicion</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
        </tr>
        <tr>
          <th>b</th>
          <td>La cámara secreta</td>
          <td>1998</td>
        </tr>
        <tr>
          <th>c</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
        </tr>
        <tr>
          <th>d</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df2.iloc[0:3, :2]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>titulo</th>
          <th>paginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>La piedra filosofal</td>
          <td>223</td>
        </tr>
        <tr>
          <th>b</th>
          <td>La cámara secreta</td>
          <td>251</td>
        </tr>
        <tr>
          <th>c</th>
          <td>El prisionero de Azkaban</td>
          <td>317</td>
        </tr>
      </tbody>
    </table>
    </div>



También se puede acceder a una parte de la tabla a partir de la
aplicación de una condición. Veamos por ejemplo qué libros salieron en
el siglo XXI. Para eso vemos qué elementos tienen valor de
``primera_edicion`` mayor a 2000:

.. code:: python

    df2['primer_edicion'] > 2000




.. parsed-literal::

    a    False
    b    False
    c    False
    d    False
    e     True
    f     True
    g     True
    Name: primer_edicion, dtype: bool



.. code:: python

    df2[df2['primer_edicion'] > 2000]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>titulo</th>
          <th>paginas</th>
          <th>primer_edicion</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>e</th>
          <td>La orden del Fénix</td>
          <td>766</td>
          <td>2003</td>
        </tr>
        <tr>
          <th>f</th>
          <td>El misterio del príncipe</td>
          <td>607</td>
          <td>2005</td>
        </tr>
        <tr>
          <th>g</th>
          <td>Las reliquias de la muerte</td>
          <td>607</td>
          <td>2007</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    print(type(df2[df2['primer_edicion'] > 2000]))


.. parsed-literal::

    <class 'pandas.core.frame.DataFrame'>


Modificando valores
-------------------

Retomemos nuestro ``DataFrame`` inicial y agreguémosle una columna con
la calificación promedio de cada libro dada por los lectores:

.. code:: python

    df = pd.DataFrame(data)
    display(df)



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
        </tr>
      </tbody>
    </table>
    </div>


.. code:: python

    df['Calificación'] = [4.5, 4.3, 4.6, 4.8, 4.7, 4.9, 4.9]
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
          <td>4.8</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
        </tr>
      </tbody>
    </table>
    </div>



Supongamos que queremos agregar una columna ``Siglo`` con el siglo en
que fue escrito cada libro. Empecemos creando una columna:

.. code:: python

    df['Siglo'] = ""
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Siglo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td></td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td></td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td></td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
          <td>4.8</td>
          <td></td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td></td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td></td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td></td>
        </tr>
      </tbody>
    </table>
    </div>



Esto crea la columna ``Siglo`` que no existe en la tabla, y le asigna el
valor ``""`` a todas las filas. Podríamos haber completado la columna
con una lista *con la misma cantidad de filas que la tabla*, pero mejor
vamos a seleccionar aquellos libros del siglo XX, y completaremos los
correspondientes valores en la nueva columna. Lo mismo haremos con los
del siglo XXI:

.. code:: python

    df.loc[df['Año de edición'] <= 2000, 'Siglo'] = 'XX'
    df.loc[df['Año de edición'] > 2000, 'Siglo'] = 'XXI'
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Siglo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
          <td>4.8</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
      </tbody>
    </table>
    </div>



Uno podría hacer algo como lo siguiente (se llama *chaining*):

.. code:: python

    df.loc[df['Año de edición'] <= 2000]['Siglo'] = 'siglo XX'
    df


.. parsed-literal::

    /tmp/ipykernel_6835/1865813456.py:1: SettingWithCopyWarning: 
    A value is trying to be set on a copy of a slice from a DataFrame.
    Try using .loc[row_indexer,col_indexer] = value instead
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
      df.loc[df['Año de edición'] <= 2000]['Siglo'] = 'siglo XX'




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Siglo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>3</th>
          <td>El cáliz de fuego</td>
          <td>2000</td>
          <td>636</td>
          <td>4.8</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
      </tbody>
    </table>
    </div>



¿Qué pasó? Por la forma en que ``pandas`` obtiene los valores pedidos
por la máscara ``df['Año de edición'] <= 2000``, el proceso de
*chaining* genera un ``DataFrame`` intermedio que es el que se pretende
modificar con ``['Siglo']``. El resultado es que ``df`` no se modifica.

   Para evitar estos inconvenientes, no se recomienda usar *chaining* al
   hacer modificaciones en los ``DataFrame``\ s.

Para borrar filas o columnas, usamos ``.drop``:

.. code:: python

    df = df.drop(3)
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Siglo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Siglo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.drop('Siglo',axis=1) # no modifica el dataframe original
    display(df)
    df.drop('Siglo',axis=1, inplace=True) # modifica el dataframe original 
    display(df)



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Siglo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td>XX</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td>XXI</td>
        </tr>
      </tbody>
    </table>
    </div>



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
        </tr>
      </tbody>
    </table>
    </div>


Supongamos ahora que tenemos un ``DataFrame`` (o una serie) con el
número de capítulos de los libros:

.. code:: python

    capitulos_data = {
        "Titulo": [
            "The Philosopher's Stone",
            "The Chamber of Secrets",
            "The Prisoner of Azkaban",
            "The Goblet of Fire",
            "The Order of the Phoenix",
            "The Half-Blood Prince",
            "The Deathly Hallows"
        ],
        "Capítulos": [17, 18, 22, 37, 38, 30, 36]
    }
    
    capitulos = pd.DataFrame(capitulos_data)
    display(capitulos)



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Capítulos</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>The Philosopher's Stone</td>
          <td>17</td>
        </tr>
        <tr>
          <th>1</th>
          <td>The Chamber of Secrets</td>
          <td>18</td>
        </tr>
        <tr>
          <th>2</th>
          <td>The Prisoner of Azkaban</td>
          <td>22</td>
        </tr>
        <tr>
          <th>3</th>
          <td>The Goblet of Fire</td>
          <td>37</td>
        </tr>
        <tr>
          <th>4</th>
          <td>The Order of the Phoenix</td>
          <td>38</td>
        </tr>
        <tr>
          <th>5</th>
          <td>The Half-Blood Prince</td>
          <td>30</td>
        </tr>
        <tr>
          <th>6</th>
          <td>The Deathly Hallows</td>
          <td>36</td>
        </tr>
      </tbody>
    </table>
    </div>


Quisiéramos agregar los datos de los capítulos a la primer tabla:

.. code:: python

    df['Capítulos'] = capitulos['Capítulos'] 
    display(df)



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Año de edición</th>
          <th>Páginas</th>
          <th>Calificación</th>
          <th>Capítulos</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>La piedra filosofal</td>
          <td>1997</td>
          <td>223</td>
          <td>4.5</td>
          <td>17</td>
        </tr>
        <tr>
          <th>1</th>
          <td>La cámara secreta</td>
          <td>1998</td>
          <td>251</td>
          <td>4.3</td>
          <td>18</td>
        </tr>
        <tr>
          <th>2</th>
          <td>El prisionero de Azkaban</td>
          <td>1999</td>
          <td>317</td>
          <td>4.6</td>
          <td>22</td>
        </tr>
        <tr>
          <th>4</th>
          <td>La orden del Fénix</td>
          <td>2003</td>
          <td>766</td>
          <td>4.7</td>
          <td>38</td>
        </tr>
        <tr>
          <th>5</th>
          <td>El misterio del príncipe</td>
          <td>2005</td>
          <td>607</td>
          <td>4.9</td>
          <td>30</td>
        </tr>
        <tr>
          <th>6</th>
          <td>Las reliquias de la muerte</td>
          <td>2007</td>
          <td>607</td>
          <td>4.9</td>
          <td>36</td>
        </tr>
      </tbody>
    </table>
    </div>


La columna queda agregada correctamente, y *no* se agrega el dato en el
libro 3 porque ya no está en ``df``. Viceversa, si queremos agregar el
número de páginas desde ``df`` a la tabla de ``capítulos``:

.. code:: python

    capitulos['Páginas'] = df['Páginas']
    display(capitulos)



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Titulo</th>
          <th>Capítulos</th>
          <th>Páginas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>The Philosopher's Stone</td>
          <td>17</td>
          <td>223.0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>The Chamber of Secrets</td>
          <td>18</td>
          <td>251.0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>The Prisoner of Azkaban</td>
          <td>22</td>
          <td>317.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>The Goblet of Fire</td>
          <td>37</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>4</th>
          <td>The Order of the Phoenix</td>
          <td>38</td>
          <td>766.0</td>
        </tr>
        <tr>
          <th>5</th>
          <td>The Half-Blood Prince</td>
          <td>30</td>
          <td>607.0</td>
        </tr>
        <tr>
          <th>6</th>
          <td>The Deathly Hallows</td>
          <td>36</td>
          <td>607.0</td>
        </tr>
      </tbody>
    </table>
    </div>


Vemos como naturalmente completa con ``Nan`` el dato inexistente. Este
comportamiento es consistente en todos los casos, ya sea copiando una
sola columna o varias, o copiando partes de la tabla utilizando listas o
rangos para su definición.

Operaciones con ``DataFrames``
------------------------------

Vamos a ver algunas operaciones de las muchas que se pueden hacer con
``DataFrame``\ s.

   Recordemos que la representación interna de los ``DataFrame``\ s es
   equivalente a los arreglos de NumPy, con lo cual siempre se podrán
   realizar cálculos a través de las funciones y métodos que provee
   dicha biblioteca.

Aritméticas
~~~~~~~~~~~

.. code:: python

    s1 = pd.DataFrame(np.arange(1,11).reshape(5,2), index = ['a', 'b', 'c', 'd', 'e'],columns=['A', 'B'])   
    s2 = pd.DataFrame(np.arange(1,11).reshape(2,5).T, index = ['a', 'g', 'h', 'd', 'e'],columns=['A', 'B'])
    display(s1,s2)



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>b</th>
          <td>3</td>
          <td>4</td>
        </tr>
        <tr>
          <th>c</th>
          <td>5</td>
          <td>6</td>
        </tr>
        <tr>
          <th>d</th>
          <td>7</td>
          <td>8</td>
        </tr>
        <tr>
          <th>e</th>
          <td>9</td>
          <td>10</td>
        </tr>
      </tbody>
    </table>
    </div>



.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>1</td>
          <td>6</td>
        </tr>
        <tr>
          <th>g</th>
          <td>2</td>
          <td>7</td>
        </tr>
        <tr>
          <th>h</th>
          <td>3</td>
          <td>8</td>
        </tr>
        <tr>
          <th>d</th>
          <td>4</td>
          <td>9</td>
        </tr>
        <tr>
          <th>e</th>
          <td>5</td>
          <td>10</td>
        </tr>
      </tbody>
    </table>
    </div>


.. code:: python

    1/s1




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>1.000000</td>
          <td>0.500000</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.333333</td>
          <td>0.250000</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.200000</td>
          <td>0.166667</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.142857</td>
          <td>0.125000</td>
        </tr>
        <tr>
          <th>e</th>
          <td>0.111111</td>
          <td>0.100000</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    s1 - 42




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>-41</td>
          <td>-40</td>
        </tr>
        <tr>
          <th>b</th>
          <td>-39</td>
          <td>-38</td>
        </tr>
        <tr>
          <th>c</th>
          <td>-37</td>
          <td>-36</td>
        </tr>
        <tr>
          <th>d</th>
          <td>-35</td>
          <td>-34</td>
        </tr>
        <tr>
          <th>e</th>
          <td>-33</td>
          <td>-32</td>
        </tr>
      </tbody>
    </table>
    </div>



Al usar dos o más ``DataFrame``\ s, el proceso de alineamiento de datos
de acuerdo a las etiquetas de las filas introduce automáticamente los
datos faltantes. Por lo tanto, aquellos valores que faltan no serán, en
este caso, sumados y resultarán también en un dato inexistente:

.. code:: python

    s1+s2




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>2.0</td>
          <td>8.0</td>
        </tr>
        <tr>
          <th>b</th>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>c</th>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>d</th>
          <td>11.0</td>
          <td>17.0</td>
        </tr>
        <tr>
          <th>e</th>
          <td>14.0</td>
          <td>20.0</td>
        </tr>
        <tr>
          <th>g</th>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>h</th>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    </div>



Es posible operar con ``DataFrame``\ s asignando un valor definido a los
datos inexistentes, con el argumento ``fill_value``:

.. code:: python

    # Función de convenciencia para mostrar dos tablas una al lado de la otra
    
    from IPython.display import display, HTML
    
    def display_side_by_side(dfs:list, captions:list):
        """Display tables side by side to save vertical space
        Input:
            dfs: list of pandas.DataFrame
            captions: list of table captions
        """
        output = ""
        combined = dict(zip(captions, dfs))
        for caption, df in combined.items():
            output += df.style.set_table_attributes("style='display:inline'").set_caption(caption)._repr_html_()
            output += "\xa0\xa0\xa0"
        display(HTML(output))

.. code:: python

    display_side_by_side([s1,s2],['s1','s2'])



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_1c516" style='display:inline'>
      <caption>s1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_1c516_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_1c516_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_1c516_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_1c516_row0_col0" class="data row0 col0" >1</td>
          <td id="T_1c516_row0_col1" class="data row0 col1" >2</td>
        </tr>
        <tr>
          <th id="T_1c516_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_1c516_row1_col0" class="data row1 col0" >3</td>
          <td id="T_1c516_row1_col1" class="data row1 col1" >4</td>
        </tr>
        <tr>
          <th id="T_1c516_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_1c516_row2_col0" class="data row2 col0" >5</td>
          <td id="T_1c516_row2_col1" class="data row2 col1" >6</td>
        </tr>
        <tr>
          <th id="T_1c516_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_1c516_row3_col0" class="data row3 col0" >7</td>
          <td id="T_1c516_row3_col1" class="data row3 col1" >8</td>
        </tr>
        <tr>
          <th id="T_1c516_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_1c516_row4_col0" class="data row4 col0" >9</td>
          <td id="T_1c516_row4_col1" class="data row4 col1" >10</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_a2f4c" style='display:inline'>
      <caption>s2</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_a2f4c_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_a2f4c_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_a2f4c_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_a2f4c_row0_col0" class="data row0 col0" >1</td>
          <td id="T_a2f4c_row0_col1" class="data row0 col1" >6</td>
        </tr>
        <tr>
          <th id="T_a2f4c_level0_row1" class="row_heading level0 row1" >g</th>
          <td id="T_a2f4c_row1_col0" class="data row1 col0" >2</td>
          <td id="T_a2f4c_row1_col1" class="data row1 col1" >7</td>
        </tr>
        <tr>
          <th id="T_a2f4c_level0_row2" class="row_heading level0 row2" >h</th>
          <td id="T_a2f4c_row2_col0" class="data row2 col0" >3</td>
          <td id="T_a2f4c_row2_col1" class="data row2 col1" >8</td>
        </tr>
        <tr>
          <th id="T_a2f4c_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_a2f4c_row3_col0" class="data row3 col0" >4</td>
          <td id="T_a2f4c_row3_col1" class="data row3 col1" >9</td>
        </tr>
        <tr>
          <th id="T_a2f4c_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_a2f4c_row4_col0" class="data row4 col0" >5</td>
          <td id="T_a2f4c_row4_col1" class="data row4 col1" >10</td>
        </tr>
      </tbody>
    </table>
       


.. code:: python

    display_side_by_side([s1,s2,s2.add(s1, fill_value=0)],['s1','s2','s2+s1'])



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_a642c" style='display:inline'>
      <caption>s1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_a642c_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_a642c_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_a642c_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_a642c_row0_col0" class="data row0 col0" >1</td>
          <td id="T_a642c_row0_col1" class="data row0 col1" >2</td>
        </tr>
        <tr>
          <th id="T_a642c_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_a642c_row1_col0" class="data row1 col0" >3</td>
          <td id="T_a642c_row1_col1" class="data row1 col1" >4</td>
        </tr>
        <tr>
          <th id="T_a642c_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_a642c_row2_col0" class="data row2 col0" >5</td>
          <td id="T_a642c_row2_col1" class="data row2 col1" >6</td>
        </tr>
        <tr>
          <th id="T_a642c_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_a642c_row3_col0" class="data row3 col0" >7</td>
          <td id="T_a642c_row3_col1" class="data row3 col1" >8</td>
        </tr>
        <tr>
          <th id="T_a642c_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_a642c_row4_col0" class="data row4 col0" >9</td>
          <td id="T_a642c_row4_col1" class="data row4 col1" >10</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_fa992" style='display:inline'>
      <caption>s2</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_fa992_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_fa992_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_fa992_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_fa992_row0_col0" class="data row0 col0" >1</td>
          <td id="T_fa992_row0_col1" class="data row0 col1" >6</td>
        </tr>
        <tr>
          <th id="T_fa992_level0_row1" class="row_heading level0 row1" >g</th>
          <td id="T_fa992_row1_col0" class="data row1 col0" >2</td>
          <td id="T_fa992_row1_col1" class="data row1 col1" >7</td>
        </tr>
        <tr>
          <th id="T_fa992_level0_row2" class="row_heading level0 row2" >h</th>
          <td id="T_fa992_row2_col0" class="data row2 col0" >3</td>
          <td id="T_fa992_row2_col1" class="data row2 col1" >8</td>
        </tr>
        <tr>
          <th id="T_fa992_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_fa992_row3_col0" class="data row3 col0" >4</td>
          <td id="T_fa992_row3_col1" class="data row3 col1" >9</td>
        </tr>
        <tr>
          <th id="T_fa992_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_fa992_row4_col0" class="data row4 col0" >5</td>
          <td id="T_fa992_row4_col1" class="data row4 col1" >10</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_c26c1" style='display:inline'>
      <caption>s2+s1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_c26c1_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_c26c1_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_c26c1_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_c26c1_row0_col0" class="data row0 col0" >2.000000</td>
          <td id="T_c26c1_row0_col1" class="data row0 col1" >8.000000</td>
        </tr>
        <tr>
          <th id="T_c26c1_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_c26c1_row1_col0" class="data row1 col0" >3.000000</td>
          <td id="T_c26c1_row1_col1" class="data row1 col1" >4.000000</td>
        </tr>
        <tr>
          <th id="T_c26c1_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_c26c1_row2_col0" class="data row2 col0" >5.000000</td>
          <td id="T_c26c1_row2_col1" class="data row2 col1" >6.000000</td>
        </tr>
        <tr>
          <th id="T_c26c1_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_c26c1_row3_col0" class="data row3 col0" >11.000000</td>
          <td id="T_c26c1_row3_col1" class="data row3 col1" >17.000000</td>
        </tr>
        <tr>
          <th id="T_c26c1_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_c26c1_row4_col0" class="data row4 col0" >14.000000</td>
          <td id="T_c26c1_row4_col1" class="data row4 col1" >20.000000</td>
        </tr>
        <tr>
          <th id="T_c26c1_level0_row5" class="row_heading level0 row5" >g</th>
          <td id="T_c26c1_row5_col0" class="data row5 col0" >2.000000</td>
          <td id="T_c26c1_row5_col1" class="data row5 col1" >7.000000</td>
        </tr>
        <tr>
          <th id="T_c26c1_level0_row6" class="row_heading level0 row6" >h</th>
          <td id="T_c26c1_row6_col0" class="data row6 col0" >3.000000</td>
          <td id="T_c26c1_row6_col1" class="data row6 col1" >8.000000</td>
        </tr>
      </tbody>
    </table>
       


.. code:: python

    s3 = pd.DataFrame(np.array([1,2]*5).reshape(5,2), index = ['a', 'g', 'h', 'd', 'e'],columns=['A', 'C'])
    display(s3)




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>g</th>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>h</th>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>d</th>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>e</th>
          <td>1</td>
          <td>2</td>
        </tr>
      </tbody>
    </table>
    </div>


La misma alineación de datos ocurre con las columnas:

.. code:: python

    display_side_by_side([s1,s3],['s1','s3'])



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_6bbd2" style='display:inline'>
      <caption>s1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_6bbd2_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_6bbd2_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_6bbd2_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_6bbd2_row0_col0" class="data row0 col0" >1</td>
          <td id="T_6bbd2_row0_col1" class="data row0 col1" >2</td>
        </tr>
        <tr>
          <th id="T_6bbd2_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_6bbd2_row1_col0" class="data row1 col0" >3</td>
          <td id="T_6bbd2_row1_col1" class="data row1 col1" >4</td>
        </tr>
        <tr>
          <th id="T_6bbd2_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_6bbd2_row2_col0" class="data row2 col0" >5</td>
          <td id="T_6bbd2_row2_col1" class="data row2 col1" >6</td>
        </tr>
        <tr>
          <th id="T_6bbd2_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_6bbd2_row3_col0" class="data row3 col0" >7</td>
          <td id="T_6bbd2_row3_col1" class="data row3 col1" >8</td>
        </tr>
        <tr>
          <th id="T_6bbd2_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_6bbd2_row4_col0" class="data row4 col0" >9</td>
          <td id="T_6bbd2_row4_col1" class="data row4 col1" >10</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_a35a5" style='display:inline'>
      <caption>s3</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_a35a5_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_a35a5_level0_col1" class="col_heading level0 col1" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_a35a5_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_a35a5_row0_col0" class="data row0 col0" >1</td>
          <td id="T_a35a5_row0_col1" class="data row0 col1" >2</td>
        </tr>
        <tr>
          <th id="T_a35a5_level0_row1" class="row_heading level0 row1" >g</th>
          <td id="T_a35a5_row1_col0" class="data row1 col0" >1</td>
          <td id="T_a35a5_row1_col1" class="data row1 col1" >2</td>
        </tr>
        <tr>
          <th id="T_a35a5_level0_row2" class="row_heading level0 row2" >h</th>
          <td id="T_a35a5_row2_col0" class="data row2 col0" >1</td>
          <td id="T_a35a5_row2_col1" class="data row2 col1" >2</td>
        </tr>
        <tr>
          <th id="T_a35a5_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_a35a5_row3_col0" class="data row3 col0" >1</td>
          <td id="T_a35a5_row3_col1" class="data row3 col1" >2</td>
        </tr>
        <tr>
          <th id="T_a35a5_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_a35a5_row4_col0" class="data row4 col0" >1</td>
          <td id="T_a35a5_row4_col1" class="data row4 col1" >2</td>
        </tr>
      </tbody>
    </table>
       


.. code:: python

    s1+s3




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>2.0</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>b</th>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>c</th>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>d</th>
          <td>8.0</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>e</th>
          <td>10.0</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>g</th>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>h</th>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    </div>



En el caso anterior, la columna B (C) no está en el ``DataFrame`` s3
(s1), por lo tanto se completan como inexistentes. Si se utiliza
``fill_value``, se completan aquellos datos con ``fill_value`` que están
en alguno de los ``DataFrame``\ s.

   Si el dato no existe en ninguno de los ``DataFrame``\ s, permanece
   como inexistente

.. code:: python

    display_side_by_side([s1,s3,s3.add(s1, fill_value=0)],['s1','s3','s3+s1'])



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_8ab45" style='display:inline'>
      <caption>s1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_8ab45_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_8ab45_level0_col1" class="col_heading level0 col1" >B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_8ab45_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_8ab45_row0_col0" class="data row0 col0" >1</td>
          <td id="T_8ab45_row0_col1" class="data row0 col1" >2</td>
        </tr>
        <tr>
          <th id="T_8ab45_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_8ab45_row1_col0" class="data row1 col0" >3</td>
          <td id="T_8ab45_row1_col1" class="data row1 col1" >4</td>
        </tr>
        <tr>
          <th id="T_8ab45_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_8ab45_row2_col0" class="data row2 col0" >5</td>
          <td id="T_8ab45_row2_col1" class="data row2 col1" >6</td>
        </tr>
        <tr>
          <th id="T_8ab45_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_8ab45_row3_col0" class="data row3 col0" >7</td>
          <td id="T_8ab45_row3_col1" class="data row3 col1" >8</td>
        </tr>
        <tr>
          <th id="T_8ab45_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_8ab45_row4_col0" class="data row4 col0" >9</td>
          <td id="T_8ab45_row4_col1" class="data row4 col1" >10</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_f43a5" style='display:inline'>
      <caption>s3</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_f43a5_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_f43a5_level0_col1" class="col_heading level0 col1" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_f43a5_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_f43a5_row0_col0" class="data row0 col0" >1</td>
          <td id="T_f43a5_row0_col1" class="data row0 col1" >2</td>
        </tr>
        <tr>
          <th id="T_f43a5_level0_row1" class="row_heading level0 row1" >g</th>
          <td id="T_f43a5_row1_col0" class="data row1 col0" >1</td>
          <td id="T_f43a5_row1_col1" class="data row1 col1" >2</td>
        </tr>
        <tr>
          <th id="T_f43a5_level0_row2" class="row_heading level0 row2" >h</th>
          <td id="T_f43a5_row2_col0" class="data row2 col0" >1</td>
          <td id="T_f43a5_row2_col1" class="data row2 col1" >2</td>
        </tr>
        <tr>
          <th id="T_f43a5_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_f43a5_row3_col0" class="data row3 col0" >1</td>
          <td id="T_f43a5_row3_col1" class="data row3 col1" >2</td>
        </tr>
        <tr>
          <th id="T_f43a5_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_f43a5_row4_col0" class="data row4 col0" >1</td>
          <td id="T_f43a5_row4_col1" class="data row4 col1" >2</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_1fc0d" style='display:inline'>
      <caption>s3+s1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_1fc0d_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_1fc0d_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_1fc0d_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_1fc0d_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_1fc0d_row0_col0" class="data row0 col0" >2.000000</td>
          <td id="T_1fc0d_row0_col1" class="data row0 col1" >2.000000</td>
          <td id="T_1fc0d_row0_col2" class="data row0 col2" >2.000000</td>
        </tr>
        <tr>
          <th id="T_1fc0d_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_1fc0d_row1_col0" class="data row1 col0" >3.000000</td>
          <td id="T_1fc0d_row1_col1" class="data row1 col1" >4.000000</td>
          <td id="T_1fc0d_row1_col2" class="data row1 col2" >nan</td>
        </tr>
        <tr>
          <th id="T_1fc0d_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_1fc0d_row2_col0" class="data row2 col0" >5.000000</td>
          <td id="T_1fc0d_row2_col1" class="data row2 col1" >6.000000</td>
          <td id="T_1fc0d_row2_col2" class="data row2 col2" >nan</td>
        </tr>
        <tr>
          <th id="T_1fc0d_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_1fc0d_row3_col0" class="data row3 col0" >8.000000</td>
          <td id="T_1fc0d_row3_col1" class="data row3 col1" >8.000000</td>
          <td id="T_1fc0d_row3_col2" class="data row3 col2" >2.000000</td>
        </tr>
        <tr>
          <th id="T_1fc0d_level0_row4" class="row_heading level0 row4" >e</th>
          <td id="T_1fc0d_row4_col0" class="data row4 col0" >10.000000</td>
          <td id="T_1fc0d_row4_col1" class="data row4 col1" >10.000000</td>
          <td id="T_1fc0d_row4_col2" class="data row4 col2" >2.000000</td>
        </tr>
        <tr>
          <th id="T_1fc0d_level0_row5" class="row_heading level0 row5" >g</th>
          <td id="T_1fc0d_row5_col0" class="data row5 col0" >1.000000</td>
          <td id="T_1fc0d_row5_col1" class="data row5 col1" >nan</td>
          <td id="T_1fc0d_row5_col2" class="data row5 col2" >2.000000</td>
        </tr>
        <tr>
          <th id="T_1fc0d_level0_row6" class="row_heading level0 row6" >h</th>
          <td id="T_1fc0d_row6_col0" class="data row6 col0" >1.000000</td>
          <td id="T_1fc0d_row6_col1" class="data row6 col1" >nan</td>
          <td id="T_1fc0d_row6_col2" class="data row6 col2" >2.000000</td>
        </tr>
      </tbody>
    </table>
       


.. code:: python

    s3.mul(s1,fill_value=1) # s3*s1




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>1.0</td>
          <td>2.0</td>
          <td>2.0</td>
        </tr>
        <tr>
          <th>b</th>
          <td>3.0</td>
          <td>4.0</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>c</th>
          <td>5.0</td>
          <td>6.0</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>d</th>
          <td>7.0</td>
          <td>8.0</td>
          <td>2.0</td>
        </tr>
        <tr>
          <th>e</th>
          <td>9.0</td>
          <td>10.0</td>
          <td>2.0</td>
        </tr>
        <tr>
          <th>g</th>
          <td>1.0</td>
          <td>NaN</td>
          <td>2.0</td>
        </tr>
        <tr>
          <th>h</th>
          <td>1.0</td>
          <td>NaN</td>
          <td>2.0</td>
        </tr>
      </tbody>
    </table>
    </div>



En resumen, las operaciones realizan una unión entre los
``DataFrame``\ s, y luego, en aquellos casos en que es factible, se
ejecuta la operación elemento a elemento.

Operaciones entre ``DataFrame`` y ``Series``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

También se pueden hacer operaciones matemáticas entre ``DataFrame`` y
``Series`` de manera similar. Sin embargo, hay que aclarar cómo se
desarrollan las operaciones dado que mientras ``DataFrame`` representa
una estructura 2D, ``Series`` es unidimensional. Por defecto, ``pandas``
propaga la serie por filas, al igual que NumPy. Esta extensión
automática de los datos se conoce como *broadcasting*:

.. code:: python

    arr2D = np.arange(12).reshape(4,3)
    arr1D = np.array([3,2,1])
    print('arr2D\n',arr2D)
    print('arr1D\n',arr1D)
    print('Broadcast')
    print(np.broadcast_to(arr1D, arr2D.shape))
    print(arr2D-arr1D)



.. parsed-literal::

    arr2D
     [[ 0  1  2]
     [ 3  4  5]
     [ 6  7  8]
     [ 9 10 11]]
    arr1D
     [3 2 1]
    Broadcast
    [[3 2 1]
     [3 2 1]
     [3 2 1]
     [3 2 1]]
    [[-3 -1  1]
     [ 0  2  4]
     [ 3  5  7]
     [ 6  8 10]]


.. code:: python

    df = pd.DataFrame(arr2D, columns = ['A', 'B', 'C'])
    v = pd.Series(arr1D, index = ['A', 'B', 'C'])
    display_side_by_side([df, pd.DataFrame(v),pd.DataFrame(np.broadcast_to(v, df.shape), columns=['A','B','C'])], ['df', 'v', 'broadcast'])
    df - arr1D  # broadcasting por filas, DataFrame - array 1D



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_61a8c" style='display:inline'>
      <caption>df</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_61a8c_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_61a8c_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_61a8c_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_61a8c_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_61a8c_row0_col0" class="data row0 col0" >0</td>
          <td id="T_61a8c_row0_col1" class="data row0 col1" >1</td>
          <td id="T_61a8c_row0_col2" class="data row0 col2" >2</td>
        </tr>
        <tr>
          <th id="T_61a8c_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_61a8c_row1_col0" class="data row1 col0" >3</td>
          <td id="T_61a8c_row1_col1" class="data row1 col1" >4</td>
          <td id="T_61a8c_row1_col2" class="data row1 col2" >5</td>
        </tr>
        <tr>
          <th id="T_61a8c_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_61a8c_row2_col0" class="data row2 col0" >6</td>
          <td id="T_61a8c_row2_col1" class="data row2 col1" >7</td>
          <td id="T_61a8c_row2_col2" class="data row2 col2" >8</td>
        </tr>
        <tr>
          <th id="T_61a8c_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_61a8c_row3_col0" class="data row3 col0" >9</td>
          <td id="T_61a8c_row3_col1" class="data row3 col1" >10</td>
          <td id="T_61a8c_row3_col2" class="data row3 col2" >11</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_beedc" style='display:inline'>
      <caption>v</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_beedc_level0_col0" class="col_heading level0 col0" >0</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_beedc_level0_row0" class="row_heading level0 row0" >A</th>
          <td id="T_beedc_row0_col0" class="data row0 col0" >3</td>
        </tr>
        <tr>
          <th id="T_beedc_level0_row1" class="row_heading level0 row1" >B</th>
          <td id="T_beedc_row1_col0" class="data row1 col0" >2</td>
        </tr>
        <tr>
          <th id="T_beedc_level0_row2" class="row_heading level0 row2" >C</th>
          <td id="T_beedc_row2_col0" class="data row2 col0" >1</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_6beba" style='display:inline'>
      <caption>broadcast</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_6beba_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_6beba_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_6beba_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_6beba_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_6beba_row0_col0" class="data row0 col0" >3</td>
          <td id="T_6beba_row0_col1" class="data row0 col1" >2</td>
          <td id="T_6beba_row0_col2" class="data row0 col2" >1</td>
        </tr>
        <tr>
          <th id="T_6beba_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_6beba_row1_col0" class="data row1 col0" >3</td>
          <td id="T_6beba_row1_col1" class="data row1 col1" >2</td>
          <td id="T_6beba_row1_col2" class="data row1 col2" >1</td>
        </tr>
        <tr>
          <th id="T_6beba_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_6beba_row2_col0" class="data row2 col0" >3</td>
          <td id="T_6beba_row2_col1" class="data row2 col1" >2</td>
          <td id="T_6beba_row2_col2" class="data row2 col2" >1</td>
        </tr>
        <tr>
          <th id="T_6beba_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_6beba_row3_col0" class="data row3 col0" >3</td>
          <td id="T_6beba_row3_col1" class="data row3 col1" >2</td>
          <td id="T_6beba_row3_col2" class="data row3 col2" >1</td>
        </tr>
      </tbody>
    </table>
       




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>-3</td>
          <td>-1</td>
          <td>1</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>2</td>
          <td>4</td>
        </tr>
        <tr>
          <th>2</th>
          <td>3</td>
          <td>5</td>
          <td>7</td>
        </tr>
        <tr>
          <th>3</th>
          <td>6</td>
          <td>8</td>
          <td>10</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df - v  # broadcasting por filas, DataFrame - Serie




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>-3</td>
          <td>-1</td>
          <td>1</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>2</td>
          <td>4</td>
        </tr>
        <tr>
          <th>2</th>
          <td>3</td>
          <td>5</td>
          <td>7</td>
        </tr>
        <tr>
          <th>3</th>
          <td>6</td>
          <td>8</td>
          <td>10</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    v - df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>3</td>
          <td>1</td>
          <td>-1</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>-2</td>
          <td>-4</td>
        </tr>
        <tr>
          <th>2</th>
          <td>-3</td>
          <td>-5</td>
          <td>-7</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-6</td>
          <td>-8</td>
          <td>-10</td>
        </tr>
      </tbody>
    </table>
    </div>



Se puede hacer el *broadcasting* en forma explícita, usando el argumento
``axis``: - Por columnas: ``axis = "index"`` (o ``axis = 0``) - Por
filas: ``axis = "columns"`` (o ``axis = 1``) que indica qué índice debe
alinearse.

.. code:: python

    w = df['A']
    display_side_by_side([df, pd.DataFrame(w)], ['df', 'w'])
    df.sub(w, axis='index') # alinea por filas, broadcasting por columnas, DataFrame - Serie



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_31b11" style='display:inline'>
      <caption>df</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_31b11_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_31b11_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_31b11_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_31b11_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_31b11_row0_col0" class="data row0 col0" >0</td>
          <td id="T_31b11_row0_col1" class="data row0 col1" >1</td>
          <td id="T_31b11_row0_col2" class="data row0 col2" >2</td>
        </tr>
        <tr>
          <th id="T_31b11_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_31b11_row1_col0" class="data row1 col0" >3</td>
          <td id="T_31b11_row1_col1" class="data row1 col1" >4</td>
          <td id="T_31b11_row1_col2" class="data row1 col2" >5</td>
        </tr>
        <tr>
          <th id="T_31b11_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_31b11_row2_col0" class="data row2 col0" >6</td>
          <td id="T_31b11_row2_col1" class="data row2 col1" >7</td>
          <td id="T_31b11_row2_col2" class="data row2 col2" >8</td>
        </tr>
        <tr>
          <th id="T_31b11_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_31b11_row3_col0" class="data row3 col0" >9</td>
          <td id="T_31b11_row3_col1" class="data row3 col1" >10</td>
          <td id="T_31b11_row3_col2" class="data row3 col2" >11</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_3b89e" style='display:inline'>
      <caption>w</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_3b89e_level0_col0" class="col_heading level0 col0" >A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_3b89e_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_3b89e_row0_col0" class="data row0 col0" >0</td>
        </tr>
        <tr>
          <th id="T_3b89e_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_3b89e_row1_col0" class="data row1 col0" >3</td>
        </tr>
        <tr>
          <th id="T_3b89e_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_3b89e_row2_col0" class="data row2 col0" >6</td>
        </tr>
        <tr>
          <th id="T_3b89e_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_3b89e_row3_col0" class="data row3 col0" >9</td>
        </tr>
      </tbody>
    </table>
       




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.sub(w, axis=0) # alinea por filas, broadcasting por columnas, DataFrame - Serie, idem axis='index'




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    t = pd.Series([3,2,1,0], index = ['A', 'B', 'C', 'D'])
    display_side_by_side([df, pd.DataFrame(t)], ['df', 't'])



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_9c47e" style='display:inline'>
      <caption>df</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_9c47e_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_9c47e_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_9c47e_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_9c47e_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_9c47e_row0_col0" class="data row0 col0" >0</td>
          <td id="T_9c47e_row0_col1" class="data row0 col1" >1</td>
          <td id="T_9c47e_row0_col2" class="data row0 col2" >2</td>
        </tr>
        <tr>
          <th id="T_9c47e_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_9c47e_row1_col0" class="data row1 col0" >3</td>
          <td id="T_9c47e_row1_col1" class="data row1 col1" >4</td>
          <td id="T_9c47e_row1_col2" class="data row1 col2" >5</td>
        </tr>
        <tr>
          <th id="T_9c47e_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_9c47e_row2_col0" class="data row2 col0" >6</td>
          <td id="T_9c47e_row2_col1" class="data row2 col1" >7</td>
          <td id="T_9c47e_row2_col2" class="data row2 col2" >8</td>
        </tr>
        <tr>
          <th id="T_9c47e_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_9c47e_row3_col0" class="data row3 col0" >9</td>
          <td id="T_9c47e_row3_col1" class="data row3 col1" >10</td>
          <td id="T_9c47e_row3_col2" class="data row3 col2" >11</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_96c60" style='display:inline'>
      <caption>t</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_96c60_level0_col0" class="col_heading level0 col0" >0</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_96c60_level0_row0" class="row_heading level0 row0" >A</th>
          <td id="T_96c60_row0_col0" class="data row0 col0" >3</td>
        </tr>
        <tr>
          <th id="T_96c60_level0_row1" class="row_heading level0 row1" >B</th>
          <td id="T_96c60_row1_col0" class="data row1 col0" >2</td>
        </tr>
        <tr>
          <th id="T_96c60_level0_row2" class="row_heading level0 row2" >C</th>
          <td id="T_96c60_row2_col0" class="data row2 col0" >1</td>
        </tr>
        <tr>
          <th id="T_96c60_level0_row3" class="row_heading level0 row3" >D</th>
          <td id="T_96c60_row3_col0" class="data row3 col0" >0</td>
        </tr>
      </tbody>
    </table>
       


.. code:: python

    df.sub(t, axis=1) # alínea por columnas, broadcasting por filas explícito, DataFrame - Serie




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>-3</td>
          <td>-1</td>
          <td>1</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>2</td>
          <td>4</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>2</th>
          <td>3</td>
          <td>5</td>
          <td>7</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>3</th>
          <td>6</td>
          <td>8</td>
          <td>10</td>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    </div>



En este último caso, dado que los índices de ``w`` y ``df`` son todos
distintos, se realiza la unión y se completa con ``NaN``.

   **En Resumen**: el eje (``axis``) es aquel en el cual se van a
   alinear los índices. Así, ``axis=0`` implica **emparejar** los
   índices de filas y **propagar** por columnas. De la misma manera,
   ``axis=1`` implica **emparejar** los índices de columnas y
   **propagar** por filas.

Orden
~~~~~

Para ordenar ``DataFrame``\ s se usa el método ``.sort_index()``

.. code:: python

    dfo = pd.DataFrame(np.random.rand(4,3), index= ['c','d','a','b'], columns = ['B', 'C', 'A'])
    dfo





.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>C</th>
          <th>A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>c</th>
          <td>0.708606</td>
          <td>0.269161</td>
          <td>0.674871</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.760163</td>
          <td>0.806327</td>
          <td>0.364229</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0.977312</td>
          <td>0.865779</td>
          <td>0.916780</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.167906</td>
          <td>0.519749</td>
          <td>0.732298</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    dfo.sort_index() # ordena por los índices de filas




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>C</th>
          <th>A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>0.977312</td>
          <td>0.865779</td>
          <td>0.916780</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.167906</td>
          <td>0.519749</td>
          <td>0.732298</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.708606</td>
          <td>0.269161</td>
          <td>0.674871</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.760163</td>
          <td>0.806327</td>
          <td>0.364229</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    dfo.sort_index(axis=1) # ordena por los índices de columnas




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>c</th>
          <td>0.674871</td>
          <td>0.708606</td>
          <td>0.269161</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.364229</td>
          <td>0.760163</td>
          <td>0.806327</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0.916780</td>
          <td>0.977312</td>
          <td>0.865779</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.732298</td>
          <td>0.167906</td>
          <td>0.519749</td>
        </tr>
      </tbody>
    </table>
    </div>



Pasando el argumento ``ascending`` (booleano) se puede cambiar el orden
por defecto, que corresponde a ``ascending=True``. Se puede ordenar
también de acuerdo a los valores de una (o múltiples) columnas
utilizando el método ``sort_values``:

.. code:: python

    dfo.sort_values('B')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>C</th>
          <th>A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>b</th>
          <td>0.167906</td>
          <td>0.519749</td>
          <td>0.732298</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.708606</td>
          <td>0.269161</td>
          <td>0.674871</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.760163</td>
          <td>0.806327</td>
          <td>0.364229</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0.977312</td>
          <td>0.865779</td>
          <td>0.916780</td>
        </tr>
      </tbody>
    </table>
    </div>



En el caso en que existieran valores faltantes, estos se ordenan al
final por defecto, excepto que se pase el argumento opcional
``na_position='first'``.

.. code:: python

    dfo.loc['c','A'] = None 
    dfo.loc['a','C'] = None
    dfo




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>C</th>
          <th>A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>c</th>
          <td>0.708606</td>
          <td>0.269161</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.760163</td>
          <td>0.806327</td>
          <td>0.364229</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0.977312</td>
          <td>NaN</td>
          <td>0.916780</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.167906</td>
          <td>0.519749</td>
          <td>0.732298</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    dfo.sort_values('C')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>C</th>
          <th>A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>c</th>
          <td>0.708606</td>
          <td>0.269161</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.167906</td>
          <td>0.519749</td>
          <td>0.732298</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.760163</td>
          <td>0.806327</td>
          <td>0.364229</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0.977312</td>
          <td>NaN</td>
          <td>0.916780</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    dfo.sort_values('C',na_position='first') # coloca los NaN al principio




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>C</th>
          <th>A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>0.977312</td>
          <td>NaN</td>
          <td>0.916780</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.708606</td>
          <td>0.269161</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.167906</td>
          <td>0.519749</td>
          <td>0.732298</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.760163</td>
          <td>0.806327</td>
          <td>0.364229</td>
        </tr>
      </tbody>
    </table>
    </div>



Una operación útil es *ranking*, esto es, asignar un valor desde 1 hasta
el número de datos de acuerdo a un orden, desde el valor más bajo al más
alto:

.. code:: python

    s = pd.Series(np.random.rand(6))
    s 




.. parsed-literal::

    0    0.395530
    1    0.030781
    2    0.572166
    3    0.195011
    4    0.986553
    5    0.178980
    dtype: float64



.. code:: python

    s.rank()




.. parsed-literal::

    0    4.0
    1    1.0
    2    5.0
    3    3.0
    4    6.0
    5    2.0
    dtype: float64



.. code:: python

    display_side_by_side([dfo, df.rank(axis=0)],['df','df.rank->0']) # ordena a lo largo de columnas
    display_side_by_side([dfo, df.rank(axis=1)],['df','df.rank->1']) # ordena a lo largo de filas



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_73bc5" style='display:inline'>
      <caption>df</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_73bc5_level0_col0" class="col_heading level0 col0" >B</th>
          <th id="T_73bc5_level0_col1" class="col_heading level0 col1" >C</th>
          <th id="T_73bc5_level0_col2" class="col_heading level0 col2" >A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_73bc5_level0_row0" class="row_heading level0 row0" >c</th>
          <td id="T_73bc5_row0_col0" class="data row0 col0" >0.708606</td>
          <td id="T_73bc5_row0_col1" class="data row0 col1" >0.269161</td>
          <td id="T_73bc5_row0_col2" class="data row0 col2" >nan</td>
        </tr>
        <tr>
          <th id="T_73bc5_level0_row1" class="row_heading level0 row1" >d</th>
          <td id="T_73bc5_row1_col0" class="data row1 col0" >0.760163</td>
          <td id="T_73bc5_row1_col1" class="data row1 col1" >0.806327</td>
          <td id="T_73bc5_row1_col2" class="data row1 col2" >0.364229</td>
        </tr>
        <tr>
          <th id="T_73bc5_level0_row2" class="row_heading level0 row2" >a</th>
          <td id="T_73bc5_row2_col0" class="data row2 col0" >0.977312</td>
          <td id="T_73bc5_row2_col1" class="data row2 col1" >nan</td>
          <td id="T_73bc5_row2_col2" class="data row2 col2" >0.916780</td>
        </tr>
        <tr>
          <th id="T_73bc5_level0_row3" class="row_heading level0 row3" >b</th>
          <td id="T_73bc5_row3_col0" class="data row3 col0" >0.167906</td>
          <td id="T_73bc5_row3_col1" class="data row3 col1" >0.519749</td>
          <td id="T_73bc5_row3_col2" class="data row3 col2" >0.732298</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_5631c" style='display:inline'>
      <caption>df.rank->0</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_5631c_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_5631c_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_5631c_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_5631c_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_5631c_row0_col0" class="data row0 col0" >1.000000</td>
          <td id="T_5631c_row0_col1" class="data row0 col1" >1.000000</td>
          <td id="T_5631c_row0_col2" class="data row0 col2" >1.000000</td>
        </tr>
        <tr>
          <th id="T_5631c_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_5631c_row1_col0" class="data row1 col0" >2.000000</td>
          <td id="T_5631c_row1_col1" class="data row1 col1" >2.000000</td>
          <td id="T_5631c_row1_col2" class="data row1 col2" >2.000000</td>
        </tr>
        <tr>
          <th id="T_5631c_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_5631c_row2_col0" class="data row2 col0" >3.000000</td>
          <td id="T_5631c_row2_col1" class="data row2 col1" >3.000000</td>
          <td id="T_5631c_row2_col2" class="data row2 col2" >3.000000</td>
        </tr>
        <tr>
          <th id="T_5631c_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_5631c_row3_col0" class="data row3 col0" >4.000000</td>
          <td id="T_5631c_row3_col1" class="data row3 col1" >4.000000</td>
          <td id="T_5631c_row3_col2" class="data row3 col2" >4.000000</td>
        </tr>
      </tbody>
    </table>
       



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_de052" style='display:inline'>
      <caption>df</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_de052_level0_col0" class="col_heading level0 col0" >B</th>
          <th id="T_de052_level0_col1" class="col_heading level0 col1" >C</th>
          <th id="T_de052_level0_col2" class="col_heading level0 col2" >A</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_de052_level0_row0" class="row_heading level0 row0" >c</th>
          <td id="T_de052_row0_col0" class="data row0 col0" >0.708606</td>
          <td id="T_de052_row0_col1" class="data row0 col1" >0.269161</td>
          <td id="T_de052_row0_col2" class="data row0 col2" >nan</td>
        </tr>
        <tr>
          <th id="T_de052_level0_row1" class="row_heading level0 row1" >d</th>
          <td id="T_de052_row1_col0" class="data row1 col0" >0.760163</td>
          <td id="T_de052_row1_col1" class="data row1 col1" >0.806327</td>
          <td id="T_de052_row1_col2" class="data row1 col2" >0.364229</td>
        </tr>
        <tr>
          <th id="T_de052_level0_row2" class="row_heading level0 row2" >a</th>
          <td id="T_de052_row2_col0" class="data row2 col0" >0.977312</td>
          <td id="T_de052_row2_col1" class="data row2 col1" >nan</td>
          <td id="T_de052_row2_col2" class="data row2 col2" >0.916780</td>
        </tr>
        <tr>
          <th id="T_de052_level0_row3" class="row_heading level0 row3" >b</th>
          <td id="T_de052_row3_col0" class="data row3 col0" >0.167906</td>
          <td id="T_de052_row3_col1" class="data row3 col1" >0.519749</td>
          <td id="T_de052_row3_col2" class="data row3 col2" >0.732298</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_2bd33" style='display:inline'>
      <caption>df.rank->1</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_2bd33_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_2bd33_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_2bd33_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_2bd33_level0_row0" class="row_heading level0 row0" >0</th>
          <td id="T_2bd33_row0_col0" class="data row0 col0" >1.000000</td>
          <td id="T_2bd33_row0_col1" class="data row0 col1" >2.000000</td>
          <td id="T_2bd33_row0_col2" class="data row0 col2" >3.000000</td>
        </tr>
        <tr>
          <th id="T_2bd33_level0_row1" class="row_heading level0 row1" >1</th>
          <td id="T_2bd33_row1_col0" class="data row1 col0" >1.000000</td>
          <td id="T_2bd33_row1_col1" class="data row1 col1" >2.000000</td>
          <td id="T_2bd33_row1_col2" class="data row1 col2" >3.000000</td>
        </tr>
        <tr>
          <th id="T_2bd33_level0_row2" class="row_heading level0 row2" >2</th>
          <td id="T_2bd33_row2_col0" class="data row2 col0" >1.000000</td>
          <td id="T_2bd33_row2_col1" class="data row2 col1" >2.000000</td>
          <td id="T_2bd33_row2_col2" class="data row2 col2" >3.000000</td>
        </tr>
        <tr>
          <th id="T_2bd33_level0_row3" class="row_heading level0 row3" >3</th>
          <td id="T_2bd33_row3_col0" class="data row3 col0" >1.000000</td>
          <td id="T_2bd33_row3_col1" class="data row3 col1" >2.000000</td>
          <td id="T_2bd33_row3_col2" class="data row3 col2" >3.000000</td>
        </tr>
      </tbody>
    </table>
       


Estadística
~~~~~~~~~~~

Es muy común en el análisis de datos tener que calcular valores
estadísticos que caracterizan la muestra. ``pandas`` provee una serie de
métodos para realizar estos cálculos.

.. code:: python

    df = pd.DataFrame(np.random.rand(4,3), index= ['a','b','c','d'], columns = ['A', 'B', 'C'])
    df





.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>0.020433</td>
          <td>0.217049</td>
          <td>0.949068</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.317689</td>
          <td>0.684951</td>
          <td>0.017181</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.622041</td>
          <td>0.421691</td>
          <td>0.776658</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.317763</td>
          <td>0.377677</td>
          <td>0.231512</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.describe()




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>count</th>
          <td>4.000000</td>
          <td>4.000000</td>
          <td>4.000000</td>
        </tr>
        <tr>
          <th>mean</th>
          <td>0.319482</td>
          <td>0.425342</td>
          <td>0.493605</td>
        </tr>
        <tr>
          <th>std</th>
          <td>0.245614</td>
          <td>0.194137</td>
          <td>0.440922</td>
        </tr>
        <tr>
          <th>min</th>
          <td>0.020433</td>
          <td>0.217049</td>
          <td>0.017181</td>
        </tr>
        <tr>
          <th>25%</th>
          <td>0.243375</td>
          <td>0.337520</td>
          <td>0.177930</td>
        </tr>
        <tr>
          <th>50%</th>
          <td>0.317726</td>
          <td>0.399684</td>
          <td>0.504085</td>
        </tr>
        <tr>
          <th>75%</th>
          <td>0.393833</td>
          <td>0.487506</td>
          <td>0.819760</td>
        </tr>
        <tr>
          <th>max</th>
          <td>0.622041</td>
          <td>0.684951</td>
          <td>0.949068</td>
        </tr>
      </tbody>
    </table>
    </div>



Cada una de las magnitudes se corresponde a algún parámetro estadístico.

Estas operaciones devuelven un nuevo ``DataFrame``. Por ejemplo:

.. code:: python

    df.sum()




.. parsed-literal::

    A    1.277927
    B    1.701367
    C    1.974419
    dtype: float64



retorna un ``DataFrame`` donde los índices corresponden a las etiquetas
de cada columna.

   Por defecto, los valores inexistentes (NA, Null, etc.) no son tenidos
   en cuenta al realizar estas operaciones.

.. code:: python

    df['A'].sum()




.. parsed-literal::

    1.2779272965340271



Aplicación de funciones y map
-----------------------------

Es posible también aplicar funciones, por ejemplo

.. code:: python

    dff = pd.DataFrame(np.random.rand(4,3), index= ['a','b','c','d'], columns = ['A', 'B', 'C'])
    dff




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>0.397259</td>
          <td>0.852559</td>
          <td>0.395104</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.546917</td>
          <td>0.361448</td>
          <td>0.622568</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.425802</td>
          <td>0.731688</td>
          <td>0.053037</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.761319</td>
          <td>0.653025</td>
          <td>0.183615</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    def f(x):
        return x.max() - x.min()
    
    dff.apply(f) # aplica la función a cada columna, por defecto axis=0





.. parsed-literal::

    A    0.364060
    B    0.491111
    C    0.569531
    dtype: float64



.. code:: python

    dff.apply(f, axis=1) # aplica la función a cada fila, axis=1




.. parsed-literal::

    a    0.457455
    b    0.261119
    c    0.678651
    d    0.577704
    dtype: float64



.. code:: python

    dff.apply(lambda x: x.max()-x.min(), axis=1) # por columnas, igual que df.apply(f, axis='columns')




.. parsed-literal::

    a    0.457455
    b    0.261119
    c    0.678651
    d    0.577704
    dtype: float64



La siguiente operación calcular el promedio de las columnas de un
``DataFrame`` e incorporarlos como una columna nueva:

.. code:: python

    dff['mean'] = dff.mean(axis=1)
    dff




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>mean</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>0.397259</td>
          <td>0.852559</td>
          <td>0.395104</td>
          <td>0.548308</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.546917</td>
          <td>0.361448</td>
          <td>0.622568</td>
          <td>0.510311</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.425802</td>
          <td>0.731688</td>
          <td>0.053037</td>
          <td>0.403509</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.761319</td>
          <td>0.653025</td>
          <td>0.183615</td>
          <td>0.532653</td>
        </tr>
      </tbody>
    </table>
    </div>



Cuál es el resultado de ``dff['mean'] = dff.mean(axis=0)``?

.. code:: python

    dff.drop('mean', axis=1, inplace=True) # elimina la columna 'mean'

.. code:: python

    dff.mean(axis=0)




.. parsed-literal::

    A    0.532824
    B    0.649680
    C    0.313581
    dtype: float64



.. code:: python

    dff['mean'] = dff.mean(axis=0)

.. code:: python

    dff




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>mean</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>a</th>
          <td>0.397259</td>
          <td>0.852559</td>
          <td>0.395104</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0.546917</td>
          <td>0.361448</td>
          <td>0.622568</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0.425802</td>
          <td>0.731688</td>
          <td>0.053037</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0.761319</td>
          <td>0.653025</td>
          <td>0.183615</td>
          <td>NaN</td>
        </tr>
      </tbody>
    </table>
    </div>



Vemos que, como no existen los índices ``A``, ``B``, ``C``, que
corresponden a las columnas que acabamos de calcular, asigna ``NaN`` en
los índices ``a``, ``b``, ``c``, ``d``

Puede ser necesario aplicar determinada función a todos los valores del
``DataFrame``, con ``map``:

.. code:: python

    def round2(x):
        return round(x, 2)
    
    
    display_side_by_side([df, df.map(round2)], ['df', 'df.map(round2)']) # aplica la función a cada elemento del DataFrame



.. raw:: html

    <style type="text/css">
    </style>
    <table id="T_1fd10" style='display:inline'>
      <caption>df</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_1fd10_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_1fd10_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_1fd10_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_1fd10_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_1fd10_row0_col0" class="data row0 col0" >0.020433</td>
          <td id="T_1fd10_row0_col1" class="data row0 col1" >0.217049</td>
          <td id="T_1fd10_row0_col2" class="data row0 col2" >0.949068</td>
        </tr>
        <tr>
          <th id="T_1fd10_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_1fd10_row1_col0" class="data row1 col0" >0.317689</td>
          <td id="T_1fd10_row1_col1" class="data row1 col1" >0.684951</td>
          <td id="T_1fd10_row1_col2" class="data row1 col2" >0.017181</td>
        </tr>
        <tr>
          <th id="T_1fd10_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_1fd10_row2_col0" class="data row2 col0" >0.622041</td>
          <td id="T_1fd10_row2_col1" class="data row2 col1" >0.421691</td>
          <td id="T_1fd10_row2_col2" class="data row2 col2" >0.776658</td>
        </tr>
        <tr>
          <th id="T_1fd10_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_1fd10_row3_col0" class="data row3 col0" >0.317763</td>
          <td id="T_1fd10_row3_col1" class="data row3 col1" >0.377677</td>
          <td id="T_1fd10_row3_col2" class="data row3 col2" >0.231512</td>
        </tr>
      </tbody>
    </table>
       <style type="text/css">
    </style>
    <table id="T_c7586" style='display:inline'>
      <caption>df.map(round2)</caption>
      <thead>
        <tr>
          <th class="blank level0" >&nbsp;</th>
          <th id="T_c7586_level0_col0" class="col_heading level0 col0" >A</th>
          <th id="T_c7586_level0_col1" class="col_heading level0 col1" >B</th>
          <th id="T_c7586_level0_col2" class="col_heading level0 col2" >C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th id="T_c7586_level0_row0" class="row_heading level0 row0" >a</th>
          <td id="T_c7586_row0_col0" class="data row0 col0" >0.020000</td>
          <td id="T_c7586_row0_col1" class="data row0 col1" >0.220000</td>
          <td id="T_c7586_row0_col2" class="data row0 col2" >0.950000</td>
        </tr>
        <tr>
          <th id="T_c7586_level0_row1" class="row_heading level0 row1" >b</th>
          <td id="T_c7586_row1_col0" class="data row1 col0" >0.320000</td>
          <td id="T_c7586_row1_col1" class="data row1 col1" >0.680000</td>
          <td id="T_c7586_row1_col2" class="data row1 col2" >0.020000</td>
        </tr>
        <tr>
          <th id="T_c7586_level0_row2" class="row_heading level0 row2" >c</th>
          <td id="T_c7586_row2_col0" class="data row2 col0" >0.620000</td>
          <td id="T_c7586_row2_col1" class="data row2 col1" >0.420000</td>
          <td id="T_c7586_row2_col2" class="data row2 col2" >0.780000</td>
        </tr>
        <tr>
          <th id="T_c7586_level0_row3" class="row_heading level0 row3" >d</th>
          <td id="T_c7586_row3_col0" class="data row3 col0" >0.320000</td>
          <td id="T_c7586_row3_col1" class="data row3 col1" >0.380000</td>
          <td id="T_c7586_row3_col2" class="data row3 col2" >0.230000</td>
        </tr>
      </tbody>
    </table>
       


--------------

Ejercicios 14 (c)
=================

6. El archivo ‘clima argentina 1981 2010.txt’ contiene datos climáticos
   significativos de las distintas estaciones meteorológicas del
   Servicio Meteorológico Nacional.

-  Inspeccione el archivo y diseñe un tipo ``DataFrame`` adecuado para
   contener dichos datos.

-  Lea el archivo y cree el ``DataFrame`` que diseño en el item
   anterior.

-  Cree una función para obtener el promedio anual de las magnitudes
   climáticas referidas en el archivo. La función debe recibir como
   argumentos el ``DataFrame``, el nombre de la estación meteorológica y
   la magnitud, y devolver un valor (``float``) con el promedio.

-  Genere un ``DataFrame`` que represente todas las magnitudes promedio
   para cada estación meteorológica, usando la función del item
   anterior.

-  Cree funciones para poder realizar gráficos comparativos de los datos
   meteorológicos. En particular, reproduzca

   -  El gráfico de Valores Medios de Temperatura y Precipitación
   -  El gráfico de Valores extremos de Temperatura, usando la
      temperatura máxima y la mínima de cada mes.

que se pueden ver en el `sitio de estadísticas del Servicio
Meteorológico Nacional <https://www.smn.gob.ar/estadisticas>`__.

--------------
