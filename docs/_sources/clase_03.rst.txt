.. _clase_03:

Clase 3: Tipos complejos y control de flujo
============================================


Listas
------

Vimos en la clase anterior el tipo “Lista”, que es un objeto que puede
contener muchos valores, de igual o distinto tipo. Veamos algunas
características

Operaciones sobre listas
~~~~~~~~~~~~~~~~~~~~~~~~

Están definidas algunas operaciones entre listas y sobre ellas. Por
ejemplo, se puede fácilmente:

-  concatenar dos listas,
-  buscar un valor dado,
-  agregar elementos,
-  borrar elementos,
-  calcular su longitud,
-  invertirla

Empecemos concatenando dos listas, usando el operador “suma”

.. code:: python

    L1 = [0,1,2,3,4,5]

.. code:: python

    L1 + L1




.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5]



.. code:: python

    2*L1 == L1 + L1




.. parsed-literal::

    True



.. code:: python

    L = 3*L1

Las listas tienen definidos métodos, que podemos ver con la ayuda
incluida, por ejemplo haciendo ``help(list)``

.. code:: python

    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5]


.. code:: python

    L.index(3)                      # Índice del elemento de valor 3




.. parsed-literal::

    3



.. code:: python

    L.index(3,4)                    # Índice del valor 3, empezando del cuarto




.. parsed-literal::

    9



.. code:: python

    L.count(3)                      # Cuenta las veces que aparece el valor "3"




.. parsed-literal::

    3



Si queremos agregar un elemento al final utilizamos el método
``append``:

.. code:: python

    L.append(8)

.. code:: python

    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 8]


.. code:: python

    L.append([9, 8, 7])
    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 8, [9, 8, 7]]


Si queremos insertar un elemento en una posición que no es el final de
la lista, usamos el método ``insert()``. Por ejemplo para insertar el
valor 6 en la primera posición:

.. code:: python

    L.insert(0,6)
    print(L)


.. parsed-literal::

    [6, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 8, [9, 8, 7]]


.. code:: python

    L.insert(-2,6)
    print(L)


.. parsed-literal::

    [6, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 8, [9, 8, 7]]


En las listas podemos sobreescribir uno o más elementos

.. code:: python

    L[0:3] = [2,3,4]
    L[4]=-4
    print(L)


.. parsed-literal::

    [2, 3, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 8, [9, 8, 7]]


.. code:: python

    L[-2:]=[0,1]
    print(L)


.. parsed-literal::

    [2, 3, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 0, 1]


.. code:: python

    L[-2:] = [7,"fin2"]

.. code:: python

    print(L)


.. parsed-literal::

    [2, 3, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 'fin2']


.. code:: python

    L.extend([0,1])                 # Extendemos con varios elementos

.. code:: python

    print(L)


.. parsed-literal::

    [2, 3, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 'fin2', 0, 1]


.. code:: python

    print(L)
    L.remove('fin2')                # Elimina la primera aparición del valor 'fin2'
    print(L)


.. parsed-literal::

    [2, 3, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 'fin2', 0, 1]
    [2, 3, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1]


.. code:: python

    L.remove(3)
    print(L)


.. parsed-literal::

    [2, 4, 2, -4, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1]


.. code:: python

    help(L.remove)


.. parsed-literal::

    Help on built-in function remove:
    
    remove(value, /) method of builtins.list instance
        Remove first occurrence of value.
    
        Raises ValueError if the value is not present.
    


.. code:: python

    print(L1)
    L1.reverse()
    print(L1)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5]
    [5, 4, 3, 2, 1, 0]


.. code:: python

    L1[::-1]




.. parsed-literal::

    [0, 1, 2, 3, 4, 5]



Función de Python que invierte un objeto iterable (como una lista)

.. code:: python

    print(list(reversed(L1)))


.. parsed-literal::

    [0, 1, 2, 3, 4, 5]


.. code:: python

    reversed(L1)




.. parsed-literal::

    <list_reverseiterator at 0x7efcf3f00a30>



El método ``sort()`` de las listas ordena sus elementos (si pueden
compararse), y acepta dos argumentos opcionales: ``key`` y ``reverse``

.. code:: python

    L.sort()          # Ordena la lista (si los elementos son comparables)
    print(L)


.. parsed-literal::

    [-4, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 7]


.. code:: python

    Ls = ['a','vaca','bote','chancho']
    Ls.sort()
    print(Ls)


.. parsed-literal::

    ['a', 'bote', 'chancho', 'vaca']


.. code:: python

    L.sort(reverse=True)            
    print(L)


.. parsed-literal::

    [7, 6, 5, 5, 5, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, -4]


Este método toma además un argumento opcional ``key``, que es una
función que se aplica a cada elemento antes de compararlos

.. code:: python

    Ls.sort(key=len)

.. code:: python

    print(Ls)


.. parsed-literal::

    ['a', 'bote', 'vaca', 'chancho']


Funciones que aplican sobre listas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hay algunas funciones de Python que se aplican sobre listas (o sobre
iterables en general). Algunas de ellas son la suma ``sum()`` e
inversión ``reversed()``

.. code:: python

    L




.. parsed-literal::

    [7, 6, 5, 5, 5, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, -4]



.. code:: python

    sum(L)




.. parsed-literal::

    57



Las funciones mínimo ``min()``, máximo ``max()`` y ordenar ``sorted()``
toman como argumento una lista (u otro iterable) de elementos que pueden
compararse entre sí

.. code:: python

    print(min(L), max(L))


.. parsed-literal::

    -4 7


.. code:: python

    print(sorted(L))


.. parsed-literal::

    [-4, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 7]


.. code:: python

    help(sorted)


.. parsed-literal::

    Help on built-in function sorted in module builtins:
    
    sorted(iterable, /, *, key=None, reverse=False)
        Return a new list containing all items from the iterable in ascending order.
    
        A custom key function can be supplied to customize the sort order, and the
        reverse flag can be set to request the result in descending order.
    


Puede encontrarse más información en `la Biblioteca de
Python <https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range>`__.

.. code:: python

    s = "abcde"
    L3 = ['hola','que','tal']
    s.join(L3)




.. parsed-literal::

    'holaabcdequeabcdetal'



.. code:: python

    " ".join(L3)




.. parsed-literal::

    'hola que tal'



.. code:: python

    print("\n".join(L3))


.. parsed-literal::

    hola
    que
    tal


--------------

Ejercicios 03 (a)
-----------------

1. Manejos de listas:

   -  Cree la lista **N** de longitud 50, donde cada elemento es un
      número entero de 1 a 50 inclusive (Ayuda: vea la expresión
      ``range``).
   -  Invierta la lista.
   -  Extraiga de **N** una lista **N1** que contenga sólo aquellos
      elementos que sean el cuadrado de algún número entero.
   -  Extraiga de **N** una lista **N2** que contenga sólo aquellos
      elementos que sean iguales al :math:`n^2-n` para algún número
      entero :math:`n`.

   *Ayuda:* Puede resultar útil recordar el uso de comprensión de
   listas.

2. Cree una lista de la forma ``L = [1,3,5,...,17,19,19,17,...,3,1]``
   (*Ayuda:* vea la expresión ``range``).

3. Escriba una función que tome un número entero de tres cifras, y
   devuelva el mayor entero que se puede formar con esas cifras
   (*Ayuda:* considere convertir el número entero a otros tipos).

4. Construya una lista ``L2`` con 2000 elementos, todos iguales a
   ``0.0005``. Imprima su suma utilizando la función ``sum`` y comparar
   con el resultado que arroja la función que existe en el módulo
   ``math`` para realizar suma de números de punto flotante.

5. Operación “rara” sobre una lista:

   -  Defina la lista ``L = [0,1]``
   -  Realice la operación ``L.append(L)``
   -  Ahora imprima L, e imprima el último elemento de ``L``.
   -  Haga que una nueva lista ``L1`` tenga el valor del último elemento
      de ``L`` y repita el inciso anterior.

--------------


Control de flujo
----------------

if/elif/else
~~~~~~~~~~~~

En todo lenguaje necesitamos controlar el flujo de una ejecución segun
una condición Verdadero/Falso (booleana). *Si (condicion) es verdadero
hacé (bloque A); Sino hacé (Bloque B)*. En pseudo código:

::

       Si condición 1:
           bloque A
       sino y condición 2:
           bloque B
       sino:
           bloque C

y en Python es muy parecido!

.. code:: python

       if condición_1:
         bloque A
       elif condicion_2:
         bloque B
       elif condicion_3:
         bloque C
       else:
         Bloque final

En un ``if``, la conversión a tipo *boolean* es implícita. El tipo
``None`` (nulo), el número ``0`` (entero, real o complejo), cualquier
secuencia (lista, tupla, string, conjunto o diccionario) vacía siempre
evalua a ``False``. Cualquier otro objeto evalua a ``True``.

Podemos tener multiples condiciones. Se ejecutará el primer bloque cuya
condición sea verdadera, o en su defecto el bloque ``else``. Esto es
equivalente a la sentencia ``switch`` de otros lenguajes.

.. code:: python

    def mensaje(Nota):
        if Nota >= 8:
            print ("Aprobó cómodo, felicitaciones!")
        elif 6 <= Nota < 8:
            print ("Bueno, al menos aprobó!")
        elif 4 <= Nota < 6 :
            print ("Bastante bien, pero no le alcanzó")
        else:
            print("Siga participando!")

.. code:: python

    mensaje(7.3)

.. code:: python

    mensaje(3)

Iteraciones
~~~~~~~~~~~

Sentencia for
^^^^^^^^^^^^^

Otro elemento de control es el que permite *iterar* sobre una secuencia
(o *“iterador”*). Obtener cada elemento para hacer algo. En Python se
logra con la sentencia ``for``. En lugar de iterar sobre una condición
aritmética hasta que se cumpla una condición (como en C o en Fortran) en
Python la sentencia ``for`` itera sobre los ítems de una secuencia en
forma ordenada

.. code:: python

    for elemento in range(10):
        print(elemento, end=', ')

Veamos otro ejemplo, iterando sobre una lista:

.. code:: python

    Lista = ['auto', 'casa', "perro", "gato", "árbol", "lechuza", "banana"]
    for L in Lista:
      print(L)

La misma sintaxis se utiliza con otros tipos que se pueden iterar
(*strings*, tuplas, conjuntos):

.. code:: python

    conj = set(Lista)

.. code:: python

    conj

.. code:: python

    for c in conj:
      print(c)

En estos ejemplos, en cada iteración ``L`` toma sucesivamente los
valores de ``Lista``. La primera vez es ``L='auto'``, la segunda
``L='casa'``, … El cuerpo del *loop* ``for``, como todos los bloques en
**Python** está definido por la **indentación**. La última línea está
fuera del loop y se ejecuta al terminar todas las iteraciones del
``for``.

.. code:: python

    for L in Lista:
      print(f'En la palabra {L} hay {L.count("a")} letras "a"')
    
    print(f'\nLa palabra más larga es {max(Lista, key=len)}')
    print(f'\nLa última palabra es {max(Lista)}')

.. note::  Acá utilizamos la función ``max()`` con un argumento requerido
  (``Lista``) que es la entidad sobre la que se va a encontrar el mayor
  valor. Notar que el mayor valor depende de como se defina la comparación
  entre dos elementos. La función ``max()`` permite un argumento opcional
  (``key``) que debe ser una “función” que se aplicará a cada elemento y
  luego se compararán los resultados de la aplicación de la función a los
  elementos. En este caso, a cada palabra se le calcula la longitud y esto
  es lo que se compara.
  
  

Otro ejemplo:

.. code:: python

    suma = 0
    for elemento in range(11):
      suma += elemento     # suma = suma + elemento
      print("x={},  suma parcial={}".format(elemento, suma))
    print ('Suma total =', suma)

Notar que utilizamos el operador asignación de suma: ``+=``.

.. code:: python

   suma += elemento

es equivalente a:

.. code:: python

   suma = suma + elemento

que corresponde a realizar la suma de la derecha, y el resultado
asignarlo a la variable de la izquierda.

Por supuesto, para obtener la suma anterior podemos simplemente usar las
funciones de python:

.. code:: python

    print (sum(range(11))) # El ejemplo anterior puede escribirse usando sum y range

Loops: ``enumerate``, ``continue``, ``break``, ``else``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Veamos otras características del bloque ``for``.

.. code:: python

    suma = 0
    cuadrados = []
    for i,elem in enumerate(range(3,30)):
      if (elem % 2) != 0:       # Si resto (%) es diferente de cero -> Impares
        continue
      suma += elem**2
      cuadrados.append(elem**2)
      print (i, elem, elem**2, suma)   # Imprimimos el índice y el elem al cuadrado
    print ("sumatoria de números pares al cuadrado entre 3 y 29:", suma)
    print ('cuadrados= ', cuadrados)

**Puntos a notar:**

-  Inicializamos una variable entera en cero y una lista vacía
-  ``range(3,30)`` nos da consecutivamente los números entre 3 y 29 en
   cada iteración.
-  ``enumerate`` nos permite iterar sobre algo, agregando un contador
   automático.
-  La línea condicional ``if elem % 2:`` es equivalente a
   ``if (elem % 2) != 0:`` y es verdadero si ``elem`` no es divisible
   por 2 (número impar)
-  La sentencia ``continue`` hace que se omita la ejecución del resto
   del bloque por esta iteración
-  El método ``append`` agrega el elemento a la lista

Antes de seguir veamos otro ejemplo de uso de ``enumerate``.
Consideremos una iteración sobre una lista como haríamos normalmente en
otros lenguajes:

.. code:: python

    L = "I've had a perfectly wonderful evening.  But this wasn't it.".split()

.. code:: python

    L

.. code:: python

    # En otros lenguajes...
    for j in range(len(L)):
      print(f'Índice: {j} -> {L[j]} ({len(L[j])} caracteres)')

.. code:: python

    # En otros lenguajes...
    for j in range(len(L)):
      print(f'La palabra "{L[j]}" tiene {len(L[j])} caracteres')


En python:

.. code:: python

    for pal in L:
      print(f'La palabra "{pal}" tiene {len(pal)} caracteres')


Hay ocasiones en que necesitamos conocer el índice. La solución de otros
lenguajes nos lo provee (nos obliga a proveerlo). Python ofrece la
función ``enumerate()`` que agrega un contador automático

.. code:: python

    for j, elem in enumerate(L):
      print(f'Índice: {j} -> {elem} ({len(elem)} caracteres)')

Veamos otro ejemplo, que puede encontrarse en la `documentación
oficial <https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops>`__:

.. code:: python

    for n in range(2, 20):
      for x in range(2, n):
        if n % x == 0:
          print( f'{n:2d} = {x} x {n//x}')
          break
      else:
         # Salió sin encontrar un factor, entonces ...
         print('{:2d} es un número primo'.format(n))


**Puntos a notar:**

-  Acá estamos usando dos *loops* anidados. Uno recorre ``n`` entre 2 y
   9, y el otro ``x`` entre 2 y ``n``.
-  La comparación ``if n % x == 0:`` chequea si ``x`` es un divisor de
   ``n``
-  La sentencia ``break`` interrumpe el *loop* interior (sobre ``x``)
-  Notar la alineación de la sentencia ``else``. No está referida a
   ``if`` sino a ``for``. Es opcional y se ejecuta cuando el loop se
   termina normalmente (sin ``break``)

While
^^^^^

Otra sentencia de control es *while*: que permite iterar mientras se
cumple una condición. El siguiente ejemplo imprime la serie de Fibonacci
(en la cuál cada término es la suma de los dos anteriores)

.. code:: python

    a, b = 0, 1
    while b < 5000:
      a, b = b, a+b
      print (b, end=' ')

.. code:: python

    a, b = 0, 1
    while b < 5000:
      a, b = b, a+b
      if b == 8:
        continue
      print (b, end=' ')


Múltiples condiciones
~~~~~~~~~~~~~~~~~~~~~

Se pueden combinar condiciones, y utilizar en los elementos de control
mediante el uso de las palabras ``and`` y ``or``. Por ejemplo:

.. code:: python

    a=3

.. code:: python

    1 < a < 4

.. code:: python

    a > 2 or a < 1

.. code:: python

    a < 1 or a > 5

.. code:: python

    a < 5 and a > 4  # Los paréntesis son opcionales

.. code:: python

    (a < 5) and (a > 4)  # Los paréntesis son opcionales

.. code:: python

    ((a < 5) and (a > 4)) or (a %2 ==1)

--------------

Ejercicios 03 (b)
-----------------

7.  De los primeros 100 números naturales imprimir aquellos que no son
    divisibles por ninguno de: 2, 3, 5 o 7.

8.  Usando estructuras de control, calcule el valor de la suma:

    .. math::  s_{1} = \frac{1}{2} \left(\sum_{k=1}^{100}k^{-1} \right)

    para los casos:

    1. Incluyendo todos los valores de ``k``
    2. Incluyendo únicamente los valores pares de ``k``.

9.  Escriba una función que estime la suma

    .. math:: s_{2} = \sum_{k=1}^{\infty} \frac{(-1)^{k} (k+1)}{2 k^{3} + k^{2}}

    La función toma como argumentos un error relativo :math:`\epsilon`
    deseado y devuelve el valor de la suma y el error relativo estimado.
    Pruebe su función para un valor :math:`\epsilon=10^{-5}`

10. Escriba una función que tome como argumento un párrafo de texto y
    devuelva un string con el párrafo en un “cartel” de un cierto ancho:

    .. code:: python

       cartelizar(parrafo, ancho)

    Por ejemplo, para el texto:

    .. code:: python

       s = "Ullam vel totam cum neque exercitationem ut. Quae omnis rerum sit reprehenderit accusamus. Molestiae molestiae sit totam sint. Neque pariatur temporibus ut minima accusantium. Ad perferendis natus nisi dolor. Et sint maiores exercitationem reiciendis ut ab et."

       sout = cartelizar(s, 60)

    debe devolver el *string*:

    .. code:: python

       sout = '* ******************************************************** *\n* Ullam vel totam cum neque exercitationem ut. Quae omnis  *\n*  rerum sit reprehenderit accusamus. Molestiae molestiae  *\n*   sit totam sint. Neque pariatur temporibus ut minima    *\n*  accusantium. Ad perferendis natus nisi dolor. Et sint   *\n* ******************************************************** *'

    que al imprimirlo se verá:

    .. code:: python

       print(sout)

    ::

        * ******************************************************** *
        * Ullam vel totam cum neque exercitationem ut. Quae omnis  *
        *  rerum sit reprehenderit accusamus. Molestiae molestiae  *
        *   sit totam sint. Neque pariatur temporibus ut minima    *
        *  accusantium. Ad perferendis natus nisi dolor. Et sint   *
        * ******************************************************** *

11. En 1949, D. R. Kaprekar, un matemático de la India especializado en
    matemática recreacional, describió un algoritmo que consiste en:

    1. Tomar un número de cuatro cifras
    2. Reacomodar las cifras para obtener el mayor número posible
    3. Obtener reacomodando las cifras también el menor posible
    4. Restarlos
    5. GOTO 1

    Este algoritmo tiene un “punto fijo” igual a **6174** y es al que el
    algoritmo llega si se inicia con un número que no tiene las cifras
    repetidas. Si alguna cifra es repetida el punto fijo puede ser el
    trivial, igual a cero. Escribir una función
    ``rutina_kaprekar(numero)`` que tome un número de cuatro cifras y
    devuelva el punto fijo y el número de números necesarios hasta
    alcanzarlo.

    Por ejemplo: Para el número 1392, la secuencia es:

    1392 -> 8082 -> 8532 -> 6174 -> 6174 -> …

    por lo que tendremos al aplicar la función:

    .. code:: python

          rutina_kaprekar(1392)

    ::

          6174, 4

.. hint::  Tenga en cuenta que si un número tiene menos de cuatro
     cifras debe agregarle ceros. Por ejemplo el número ``978`` debe
     entenderse como ``0978`` por lo que el mayor número que puede
     escribirse con estas cifras es ``9870``.
  
  

--------------

.
