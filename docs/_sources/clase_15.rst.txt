.. _clase_15:


=========================
Clase 15: Más ``pandas``
=========================

==============

Manejando datos faltantes
=========================

Hemos visto que ``pandas`` automágicamente es capaz de manejar valores
faltantes o inexistentes, a través de distintas etiquetas como ``NaN``,
``NA``, etc., dependiendo del tipo de dato que se esté utilizando. Más
allá de la lectura de los datos, muchos de los métodos nativos de
``pandas`` son capaces de trabajar aún cuando falten datos. Sin embargo,
puede ser necesario intervenir efectivamente sobre esos datos para poder
continuar con ese procesamiento.

.. code:: python

    import numpy as np 
    import pandas as pd

.. code:: python

    d = np.array([['auto','moto',np.nan,None,'bicicleta'],[4,2,0.0,None,2]])
    d





.. parsed-literal::

    array([['auto', 'moto', nan, None, 'bicicleta'],
           [4, 2, 0.0, None, 2]], dtype=object)



.. code:: python

    s = pd.DataFrame(d.T,columns=['vehículos','ruedas'])
    s




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>vehículos</th>
          <th>ruedas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>auto</td>
          <td>4</td>
        </tr>
        <tr>
          <th>1</th>
          <td>moto</td>
          <td>2</td>
        </tr>
        <tr>
          <th>2</th>
          <td>NaN</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>None</td>
          <td>None</td>
        </tr>
        <tr>
          <th>4</th>
          <td>bicicleta</td>
          <td>2</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    s.isna()





.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>vehículos</th>
          <th>ruedas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>False</td>
          <td>False</td>
        </tr>
        <tr>
          <th>1</th>
          <td>False</td>
          <td>False</td>
        </tr>
        <tr>
          <th>2</th>
          <td>True</td>
          <td>False</td>
        </tr>
        <tr>
          <th>3</th>
          <td>True</td>
          <td>True</td>
        </tr>
        <tr>
          <th>4</th>
          <td>False</td>
          <td>False</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    s.dropna() # equivalente a s[s.notna()]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>vehículos</th>
          <th>ruedas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>auto</td>
          <td>4</td>
        </tr>
        <tr>
          <th>1</th>
          <td>moto</td>
          <td>2</td>
        </tr>
        <tr>
          <th>4</th>
          <td>bicicleta</td>
          <td>2</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    s.dropna(axis=1) # equivalente a s.dropna(axis='columns')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
        </tr>
        <tr>
          <th>1</th>
        </tr>
        <tr>
          <th>2</th>
        </tr>
        <tr>
          <th>3</th>
        </tr>
        <tr>
          <th>4</th>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    s.dropna(how='all') # elimina las filas que tengan todos los valores nulos




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>vehículos</th>
          <th>ruedas</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>auto</td>
          <td>4</td>
        </tr>
        <tr>
          <th>1</th>
          <td>moto</td>
          <td>2</td>
        </tr>
        <tr>
          <th>2</th>
          <td>NaN</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>4</th>
          <td>bicicleta</td>
          <td>2</td>
        </tr>
      </tbody>
    </table>
    </div>



También se puede usar el argumento ‘thresh=’ para acotar la cantidad de
valores inexistentes que se quieren eliminar. Por ejemplo, ``thresh=3``
eliminará todas aquellas filas que tienen 3 o más valores faltantes.

Es posible también que uno no pueda trabajar con valores inexistentes, y
tiene que cambiarlos por algún valor. Para ello está el método
``fillna``.

.. code:: python

    df = pd.DataFrame(np.random.standard_normal((7, 3)),columns=['A','B','C'])
    
    df.iloc[:4,2] = np.nan
    df.iloc[1:3,0] = None 
    
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.377913</td>
          <td>-0.770393</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>1</th>
          <td>NaN</td>
          <td>-0.009935</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>2</th>
          <td>NaN</td>
          <td>0.904126</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-0.077318</td>
          <td>-0.022459</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.827397</td>
          <td>2.037912</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.047666</td>
          <td>-1.048824</td>
          <td>0.248140</td>
        </tr>
        <tr>
          <th>6</th>
          <td>-0.943052</td>
          <td>1.499018</td>
          <td>0.048949</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.fillna(0) # rellena los valores nulos con 0




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.377913</td>
          <td>-0.770393</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0.000000</td>
          <td>-0.009935</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0.000000</td>
          <td>0.904126</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-0.077318</td>
          <td>-0.022459</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.827397</td>
          <td>2.037912</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.047666</td>
          <td>-1.048824</td>
          <td>0.248140</td>
        </tr>
        <tr>
          <th>6</th>
          <td>-0.943052</td>
          <td>1.499018</td>
          <td>0.048949</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.fillna({'A':0,'C':2}) # rellena los valores nulos con 0, 1 y 2 respectivamente




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.377913</td>
          <td>-0.770393</td>
          <td>2.000000</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0.000000</td>
          <td>-0.009935</td>
          <td>2.000000</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0.000000</td>
          <td>0.904126</td>
          <td>2.000000</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-0.077318</td>
          <td>-0.022459</td>
          <td>2.000000</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.827397</td>
          <td>2.037912</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.047666</td>
          <td>-1.048824</td>
          <td>0.248140</td>
        </tr>
        <tr>
          <th>6</th>
          <td>-0.943052</td>
          <td>1.499018</td>
          <td>0.048949</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.ffill() # rellena los valores nulos con el valor anterior




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.377913</td>
          <td>-0.770393</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0.377913</td>
          <td>-0.009935</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0.377913</td>
          <td>0.904126</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-0.077318</td>
          <td>-0.022459</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.827397</td>
          <td>2.037912</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.047666</td>
          <td>-1.048824</td>
          <td>0.248140</td>
        </tr>
        <tr>
          <th>6</th>
          <td>-0.943052</td>
          <td>1.499018</td>
          <td>0.048949</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.ffill(axis=1) # rellena los valores nulos con el valor anterior en la misma fila




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.377913</td>
          <td>-0.770393</td>
          <td>-0.770393</td>
        </tr>
        <tr>
          <th>1</th>
          <td>NaN</td>
          <td>-0.009935</td>
          <td>-0.009935</td>
        </tr>
        <tr>
          <th>2</th>
          <td>NaN</td>
          <td>0.904126</td>
          <td>0.904126</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-0.077318</td>
          <td>-0.022459</td>
          <td>-0.022459</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.827397</td>
          <td>2.037912</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.047666</td>
          <td>-1.048824</td>
          <td>0.248140</td>
        </tr>
        <tr>
          <th>6</th>
          <td>-0.943052</td>
          <td>1.499018</td>
          <td>0.048949</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.bfill() # rellena los valores nulos con el valor siguiente




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.377913</td>
          <td>-0.770393</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>1</th>
          <td>-0.077318</td>
          <td>-0.009935</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>2</th>
          <td>-0.077318</td>
          <td>0.904126</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>3</th>
          <td>-0.077318</td>
          <td>-0.022459</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.827397</td>
          <td>2.037912</td>
          <td>-0.418672</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.047666</td>
          <td>-1.048824</td>
          <td>0.248140</td>
        </tr>
        <tr>
          <th>6</th>
          <td>-0.943052</td>
          <td>1.499018</td>
          <td>0.048949</td>
        </tr>
      </tbody>
    </table>
    </div>



Estos métodos para reemplazar de valores inexistentes son un caso
particular de un método para reemplazar valores en forma general,
denominado ``replace`` y puede ser útil para reemplazar valores que, por
alguna razón, se encuentran fuera del rango esperado de los datos (un
precio negativo, una edad mayor a 120 años, etc.). Veamos cómo funciona:

.. code:: python

    p = pd.Series([23,4,-8,12,27,-9])
    p




.. parsed-literal::

    0    23
    1     4
    2    -8
    3    12
    4    27
    5    -9
    dtype: int64



.. code:: python

    p.replace(-9,np.nan) # reemplaza -9 por NaN




.. parsed-literal::

    0    23.0
    1     4.0
    2    -8.0
    3    12.0
    4    27.0
    5     NaN
    dtype: float64



.. code:: python

    p.replace({-9:np.nan,-8:0}) # reemplaza -9 por NaN y 23 por 0




.. parsed-literal::

    0    23.0
    1     4.0
    2     0.0
    3    12.0
    4    27.0
    5     NaN
    dtype: float64



.. code:: python

    p<0 




.. parsed-literal::

    0    False
    1    False
    2     True
    3    False
    4    False
    5     True
    dtype: bool



.. code:: python

    p[p < 0]




.. parsed-literal::

    2   -8
    5   -9
    dtype: int64



.. code:: python

    list(p[p < 0])




.. parsed-literal::

    [-8, -9]



.. code:: python

    p.replace(list(p[p < 0]),[86,22]) # encuentro los valores < 0 y los reemplazo por 86 y 22 respectivamente




.. parsed-literal::

    0    23
    1     4
    2    86
    3    12
    4    27
    5    22
    dtype: int64



   **Nota:** el método ``replace()`` genera un nuevo dato.

Indicadores
===========

Otro tipo de transformación para el modelado estadístico es convertir
una variable en un *indicador*. Si una columna en un ``DataFrame`` tiene
k valores distintos, se derivará una matriz o ``DataFrame`` con k
columnas conteniendo unos y ceros, por ejemplo:

.. code:: python

    df = pd.DataFrame({'key': ['a','a','b','d','a','c','c'],'datos': np.random.standard_normal(7)})
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>key</th>
          <th>datos</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>a</td>
          <td>-0.680732</td>
        </tr>
        <tr>
          <th>1</th>
          <td>a</td>
          <td>0.021716</td>
        </tr>
        <tr>
          <th>2</th>
          <td>b</td>
          <td>0.722098</td>
        </tr>
        <tr>
          <th>3</th>
          <td>d</td>
          <td>-0.671279</td>
        </tr>
        <tr>
          <th>4</th>
          <td>a</td>
          <td>1.547057</td>
        </tr>
        <tr>
          <th>5</th>
          <td>c</td>
          <td>-0.880381</td>
        </tr>
        <tr>
          <th>6</th>
          <td>c</td>
          <td>-0.633695</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    pd.get_dummies(df['key'],dtype=int) # crea variables dummy




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <th>4</th>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
        </tr>
        <tr>
          <th>6</th>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
        </tr>
      </tbody>
    </table>
    </div>



Manejando índices múltiples
===========================

Hemos visto hasta ahora que los índices nos etiquetan cada una de las
filas de un ``DataFrame``. Pandas tiene la posibilidad de utilizar
índices múltiples o *jerárquicos* con el objeto de añadir
dimensionalidad a las tablas. La implementación de esta característica
consiste en utilizar tuplas como índices para etiquetar cada fila:

.. code:: python

    # Índices jerárquicos: ciudades, productos, años
    index = [
        ("Buenos Aires", "Zapatos", 2022),
        ("Buenos Aires", "Ropa", 2022),
        ("Buenos Aires", "Ropa", 2023),
        ("Córdoba", "Zapatos", 2023),
        ("Córdoba", "Ropa", 2023),
        ("Rosario", "Zapatos", 2023),
    ]

.. code:: python

    index = pd.MultiIndex.from_tuples(index, names=["Ciudad", "Producto", "Año"])
    print(type(index))
    index


.. parsed-literal::

    <class 'pandas.core.indexes.multi.MultiIndex'>




.. parsed-literal::

    MultiIndex([('Buenos Aires', 'Zapatos', 2022),
                ('Buenos Aires',    'Ropa', 2022),
                ('Buenos Aires',    'Ropa', 2023),
                (     'Córdoba', 'Zapatos', 2023),
                (     'Córdoba',    'Ropa', 2023),
                (     'Rosario', 'Zapatos', 2023)],
               names=['Ciudad', 'Producto', 'Año'])



.. code:: python

    # Datos
    data = {
        "Ventas": [200, 150, 300, 400, 250, 500],
        "Costo": [120, 80, 180, 240, 150, 300]
    }

.. code:: python

    df = pd.DataFrame(data, index=index)
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th></th>
          <th></th>
          <th>Ventas</th>
          <th>Costo</th>
        </tr>
        <tr>
          <th>Ciudad</th>
          <th>Producto</th>
          <th>Año</th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th rowspan="3" valign="top">Buenos Aires</th>
          <th>Zapatos</th>
          <th>2022</th>
          <td>200</td>
          <td>120</td>
        </tr>
        <tr>
          <th rowspan="2" valign="top">Ropa</th>
          <th>2022</th>
          <td>150</td>
          <td>80</td>
        </tr>
        <tr>
          <th>2023</th>
          <td>300</td>
          <td>180</td>
        </tr>
        <tr>
          <th rowspan="2" valign="top">Córdoba</th>
          <th>Zapatos</th>
          <th>2023</th>
          <td>400</td>
          <td>240</td>
        </tr>
        <tr>
          <th>Ropa</th>
          <th>2023</th>
          <td>250</td>
          <td>150</td>
        </tr>
        <tr>
          <th>Rosario</th>
          <th>Zapatos</th>
          <th>2023</th>
          <td>500</td>
          <td>300</td>
        </tr>
      </tbody>
    </table>
    </div>



Si queremos obtener ciertas filas específicas, usamos ``.loc``.

.. code:: python

    # Acceso por niveles del índice
    print("\nDatos de 'Buenos Aires' en 2022:")
    print(df.loc[("Buenos Aires", slice(None), 2022), :])


.. parsed-literal::

    
    Datos de 'Buenos Aires' en 2022:
                                Ventas  Costo
    Ciudad       Producto Año                
    Buenos Aires Zapatos  2022     200    120
                 Ropa     2022     150     80


La función ``slice`` se usa para determinar el rango de filas en cada
componente del índice. ``slice(None)`` implica usar todos los valores
posibles para dicha componente del índice.

Agrupando
---------

La potencia de los índices múltiples radica en poder agrupar datos de
acuerdo a una determinada componente del índice. Para ello se utiliza el
método ``.groupby()``, que agrupa los valores de acuerdo al nivel
(``level``) indicado:

.. code:: python

    # Resumen por nivel del índice
    print("\nVentas totales por ciudad:")
    print(df.groupby(level="Ciudad")["Ventas"].sum())


.. parsed-literal::

    
    Ventas totales por ciudad:
    Ciudad
    Buenos Aires    650
    Córdoba         650
    Rosario         500
    Name: Ventas, dtype: int64


Si uno quisiera calcular el monto total de ventas por ciudad y por año,
por ejemplo, se podría hacer:

.. code:: python

    # Agrupar por 'Ciudad' y 'Año' y sumar el costo
    df["Total"] = df["Ventas"] * df["Costo"]
    df





.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th></th>
          <th></th>
          <th>Ventas</th>
          <th>Costo</th>
          <th>Total</th>
        </tr>
        <tr>
          <th>Ciudad</th>
          <th>Producto</th>
          <th>Año</th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th rowspan="3" valign="top">Buenos Aires</th>
          <th>Zapatos</th>
          <th>2022</th>
          <td>200</td>
          <td>120</td>
          <td>24000</td>
        </tr>
        <tr>
          <th rowspan="2" valign="top">Ropa</th>
          <th>2022</th>
          <td>150</td>
          <td>80</td>
          <td>12000</td>
        </tr>
        <tr>
          <th>2023</th>
          <td>300</td>
          <td>180</td>
          <td>54000</td>
        </tr>
        <tr>
          <th rowspan="2" valign="top">Córdoba</th>
          <th>Zapatos</th>
          <th>2023</th>
          <td>400</td>
          <td>240</td>
          <td>96000</td>
        </tr>
        <tr>
          <th>Ropa</th>
          <th>2023</th>
          <td>250</td>
          <td>150</td>
          <td>37500</td>
        </tr>
        <tr>
          <th>Rosario</th>
          <th>Zapatos</th>
          <th>2023</th>
          <td>500</td>
          <td>300</td>
          <td>150000</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    costo_anual_ciudad_x_año = df.groupby(level=["Ciudad", "Año"])["Total"].sum()
    
    # Mostrar el resultado
    print("Costo anual por ciudad por año:")
    print(costo_anual_ciudad_x_año)



.. parsed-literal::

    Costo anual por ciudad por año:
    Ciudad        Año 
    Buenos Aires  2022     36000
                  2023     54000
    Córdoba       2023    133500
    Rosario       2023    150000
    Name: Total, dtype: int64


.. code:: python

    costo_anual_ciudad = df.groupby(level=["Ciudad"])["Total"].sum()
    
    # Mostrar el resultado
    print("Costo anual por ciudad:")
    print(costo_anual_ciudad)


.. parsed-literal::

    Costo anual por ciudad:
    Ciudad
    Buenos Aires     90000
    Córdoba         133500
    Rosario         150000
    Name: Total, dtype: int64


Apilando y desapilando
======================

Otra operación es apilar o desapilar el dataframe de índices múltiples:

.. code:: python

    df.unstack() # desapila el índice




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead tr th {
            text-align: left;
        }
    
        .dataframe thead tr:last-of-type th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr>
          <th></th>
          <th></th>
          <th colspan="2" halign="left">Ventas</th>
          <th colspan="2" halign="left">Costo</th>
          <th colspan="2" halign="left">Total</th>
        </tr>
        <tr>
          <th></th>
          <th>Año</th>
          <th>2022</th>
          <th>2023</th>
          <th>2022</th>
          <th>2023</th>
          <th>2022</th>
          <th>2023</th>
        </tr>
        <tr>
          <th>Ciudad</th>
          <th>Producto</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th rowspan="2" valign="top">Buenos Aires</th>
          <th>Ropa</th>
          <td>150.0</td>
          <td>300.0</td>
          <td>80.0</td>
          <td>180.0</td>
          <td>12000.0</td>
          <td>54000.0</td>
        </tr>
        <tr>
          <th>Zapatos</th>
          <td>200.0</td>
          <td>NaN</td>
          <td>120.0</td>
          <td>NaN</td>
          <td>24000.0</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th rowspan="2" valign="top">Córdoba</th>
          <th>Ropa</th>
          <td>NaN</td>
          <td>250.0</td>
          <td>NaN</td>
          <td>150.0</td>
          <td>NaN</td>
          <td>37500.0</td>
        </tr>
        <tr>
          <th>Zapatos</th>
          <td>NaN</td>
          <td>400.0</td>
          <td>NaN</td>
          <td>240.0</td>
          <td>NaN</td>
          <td>96000.0</td>
        </tr>
        <tr>
          <th>Rosario</th>
          <th>Zapatos</th>
          <td>NaN</td>
          <td>500.0</td>
          <td>NaN</td>
          <td>300.0</td>
          <td>NaN</td>
          <td>150000.0</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df.unstack().columns




.. parsed-literal::

    MultiIndex([('Ventas', 2022),
                ('Ventas', 2023),
                ( 'Costo', 2022),
                ( 'Costo', 2023),
                ( 'Total', 2022),
                ( 'Total', 2023)],
               names=[None, 'Año'])



Tal como se ve en el ejemplo anterior, **las columnas también pueden ser
descriptas con índices jerárquicos**

.. code:: python

    df.unstack().unstack() # desapila el índice




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead tr th {
            text-align: left;
        }
    
        .dataframe thead tr:last-of-type th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr>
          <th></th>
          <th colspan="4" halign="left">Ventas</th>
          <th colspan="4" halign="left">Costo</th>
          <th colspan="4" halign="left">Total</th>
        </tr>
        <tr>
          <th>Año</th>
          <th colspan="2" halign="left">2022</th>
          <th colspan="2" halign="left">2023</th>
          <th colspan="2" halign="left">2022</th>
          <th colspan="2" halign="left">2023</th>
          <th colspan="2" halign="left">2022</th>
          <th colspan="2" halign="left">2023</th>
        </tr>
        <tr>
          <th>Producto</th>
          <th>Ropa</th>
          <th>Zapatos</th>
          <th>Ropa</th>
          <th>Zapatos</th>
          <th>Ropa</th>
          <th>Zapatos</th>
          <th>Ropa</th>
          <th>Zapatos</th>
          <th>Ropa</th>
          <th>Zapatos</th>
          <th>Ropa</th>
          <th>Zapatos</th>
        </tr>
        <tr>
          <th>Ciudad</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Buenos Aires</th>
          <td>150.0</td>
          <td>200.0</td>
          <td>300.0</td>
          <td>NaN</td>
          <td>80.0</td>
          <td>120.0</td>
          <td>180.0</td>
          <td>NaN</td>
          <td>12000.0</td>
          <td>24000.0</td>
          <td>54000.0</td>
          <td>NaN</td>
        </tr>
        <tr>
          <th>Córdoba</th>
          <td>NaN</td>
          <td>NaN</td>
          <td>250.0</td>
          <td>400.0</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>150.0</td>
          <td>240.0</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>37500.0</td>
          <td>96000.0</td>
        </tr>
        <tr>
          <th>Rosario</th>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>500.0</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>300.0</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>NaN</td>
          <td>150000.0</td>
        </tr>
      </tbody>
    </table>
    </div>



Categorías
==========

Es muy posible que en nuestro conjunto de datos tengamos valores
repetidos.

.. code:: python

    s = pd.Series(["Pequeño", "Mediano", "Grande", "Pequeño", "Grande", "Mediano"])
    s




.. parsed-literal::

    0    Pequeño
    1    Mediano
    2     Grande
    3    Pequeño
    4     Grande
    5    Mediano
    dtype: object



.. code:: python

    s_cat = s.astype("category")
    s_cat




.. parsed-literal::

    0    Pequeño
    1    Mediano
    2     Grande
    3    Pequeño
    4     Grande
    5    Mediano
    dtype: category
    Categories (3, object): ['Grande', 'Mediano', 'Pequeño']



.. code:: python

    s_cat.cat.categories





.. parsed-literal::

    Index(['Grande', 'Mediano', 'Pequeño'], dtype='object')



.. code:: python

    s_cat.cat.codes




.. parsed-literal::

    0    2
    1    1
    2    0
    3    2
    4    0
    5    1
    dtype: int8



.. code:: python

    dict(enumerate(s_cat.cat.categories))




.. parsed-literal::

    {0: 'Grande', 1: 'Mediano', 2: 'Pequeño'}



En el caso de un ``DataFrame``, uno puede convertir una columna en una
categoría reasignandola:

.. code:: python

    precios = [100, 200, 300, 150, 250, 180]
    
    df = pd.DataFrame({'precios':precios,'tamaño':s})
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>precios</th>
          <th>tamaño</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>100</td>
          <td>Pequeño</td>
        </tr>
        <tr>
          <th>1</th>
          <td>200</td>
          <td>Mediano</td>
        </tr>
        <tr>
          <th>2</th>
          <td>300</td>
          <td>Grande</td>
        </tr>
        <tr>
          <th>3</th>
          <td>150</td>
          <td>Pequeño</td>
        </tr>
        <tr>
          <th>4</th>
          <td>250</td>
          <td>Grande</td>
        </tr>
        <tr>
          <th>5</th>
          <td>180</td>
          <td>Mediano</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    df['tamaño']




.. parsed-literal::

    0    Pequeño
    1    Mediano
    2     Grande
    3    Pequeño
    4     Grande
    5    Mediano
    Name: tamaño, dtype: object



.. code:: python

    df['tamaño'] = df['tamaño'].astype('category')
    df['tamaño']




.. parsed-literal::

    0    Pequeño
    1    Mediano
    2     Grande
    3    Pequeño
    4     Grande
    5    Mediano
    Name: tamaño, dtype: category
    Categories (3, object): ['Grande', 'Mediano', 'Pequeño']



El beneficio principal del uso de categorías tiene que ver con la
eficiencia en la memoria y en las operaciones:

.. code:: python

    N = 10_000_000
    
    s = pd.Series(['a','b','c','d']* (N//4))
    s_cat = s.astype('category')

.. code:: python

    print(s.memory_usage(deep=True))
    print(s_cat.memory_usage(deep=True))


.. parsed-literal::

    500000132
    10000504


.. code:: python

    %timeit s.value_counts()


.. parsed-literal::

    363 ms ± 15.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)


.. code:: python

    %timeit s_cat.value_counts()


.. parsed-literal::

    38.9 ms ± 2.77 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)


--------------

Ejercicio 15 (a)
================

1. Retome el ``DataFrame`` creado en el ejercicio 14(a), y genere un
   nuevo ``DataFrame`` utilizando adecuadamente índices jerárquicos.

--------------



Graficando ``DataFrames``
=========================

Vamos a ver brevemente cómo usar ``matplotlib`` para graficar
``DataFrames`` de ``pandas``. La mecánica para utilizar otras
bibliotecas de graficación (``seaborn``, ``plotly``, etc.) es similar

.. code:: python

    import pandas as pd
    import matplotlib.pyplot as plt
    import numpy as np

.. code:: python

    s = pd.Series(np.random.standard_normal(1000).cumsum(), index=pd.date_range('2021-1-1', periods=1000))
    s




.. parsed-literal::

    2021-01-01     0.446463
    2021-01-02     0.979651
    2021-01-03     1.640311
    2021-01-04     0.619966
    2021-01-05     0.561815
                    ...    
    2023-09-23   -30.301808
    2023-09-24   -30.761436
    2023-09-25   -30.141886
    2023-09-26   -30.961800
    2023-09-27   -31.042287
    Freq: D, Length: 1000, dtype: float64



.. code:: python

    s.plot()




.. parsed-literal::

    <Axes: >




.. image:: figuras/15_2_pandas_y_plot_3_1.png


.. code:: python

    s.plot(label='random series',style='r--',legend=True, title='Random Series', grid=True)




.. parsed-literal::

    <Axes: title={'center': 'Random Series'}>




.. image:: figuras/15_2_pandas_y_plot_4_1.png


.. code:: python

    df = pd.DataFrame({'A': np.random.standard_normal(100)+2, 'B': np.random.standard_normal(100), 'C': np.random.standard_normal(100)-2, 'D': np.random.randn(100) }, index=pd.date_range('2019-1-1', periods=100))
    df.plot()




.. parsed-literal::

    <Axes: >




.. image:: figuras/15_2_pandas_y_plot_5_1.png


.. code:: python

    df.plot(legend=True, title='Random DataFrame', grid=True, style=['r--','g-','b.','co-'], kind='line')




.. parsed-literal::

    <Axes: title={'center': 'Random DataFrame'}>




.. image:: figuras/15_2_pandas_y_plot_6_1.png


.. code:: python

    fig, axes = plt.subplots(2, 2)
    
    df['A'].plot(ax=axes[0,0], legend=True, title=df.columns[0])
    df['B'].plot(ax=axes[0,1], legend=True, title=df.columns[1])
    df['C'].plot(ax=axes[1,0], legend=True, title=df.columns[2])
    df['D'].plot(ax=axes[1,1], legend=True, title=df.columns[3])




.. parsed-literal::

    <Axes: title={'center': 'D'}>




.. image:: figuras/15_2_pandas_y_plot_7_1.png


Podría ser interesante graficar una columna respecto de otra, en lugar
de usar el índice como etiquetas del eje x:

.. code:: python

    df.plot(x='A', y='B', kind='scatter')




.. parsed-literal::

    <Axes: xlabel='A', ylabel='B'>




.. image:: figuras/15_2_pandas_y_plot_9_1.png


.. code:: python

    plt.plot(df['A'],df['B'])
    plt.plot(df['B'],df['D'])




.. parsed-literal::

    [<matplotlib.lines.Line2D at 0x7f13c0a2c410>]




.. image:: figuras/15_2_pandas_y_plot_10_1.png


Y se pueden hacer fácilmente `otros tipos de
gráficos <https://pandas.pydata.org/docs/user_guide/visualization.html#other-plots>`__:

.. code:: python

    df.iloc[:10].abs().plot.bar()




.. parsed-literal::

    <Axes: >




.. image:: figuras/15_2_pandas_y_plot_12_1.png


--------------

Ejercicio 15(b)
===============

2. En el archivo ``com3500.csv`` se encuentra la cotización promedio del
   dolar en Argentina desde 2002. Lea el archivo en un DataFrame de
   pandas y

-  Realice un gráfico claro y bello
-  Observe que la información del mes está dada en ``nombre_del_mes-xx``
   donde ``xx`` es el año. Separe dicha columna en dos, una
   correspondiente al mes, y otra correspondiente al año.
-  Agrupe la información por año y grafique la evolución del precio del
   dólar por año.

--------------

Análisis de código: Problema de niveles
=======================================

Se define un *nivel* como una colección de números naturales. Un nivel
tiene status de *válido* si la colección de números es estrictamente
ascendente o estrictamente descendente. En caso contrario el nivel se
declara *inválido* . Por ejemplo, ``[9, 7, 6, 2, 1]`` es descendente,
dado que

.. math::  9 > 7 > 6 > 2 >1 .

\ El nivel ``[1, 2, 3, 4, 7]`` es ascendente ya que

.. math::  1 < 2 < 3 < 4 < 7.

Ambos son niveles válidos. Sin embargo, ``[7, 9, 6, 2, 1]`` es un nivel
inválido, dado que

.. math::  7 < 9 ,

pero

.. math::  9 > 6 > 2 > 1 .

El nivel ``[2, 2, 1]`` tampoco es un nivel válido ya que los dos
primeros valores son iguales.

Existe una tercera categoría para el status de un nivel. Un nivel se
define como *tolerable* si y sólo si removiendo **exactamente** uno de
sus elementos, el nivel es estrictamente descendente o ascendente. Por
ejemplo, ``[ 7, 9, 6, 2, 1]`` es un nivel tolerable dado que si se
remueve el elemento ``7``, el nivel es estrictamente descendente.

Hemos recibido un código **(data/codigo2.py)** que verifica si un
conjunto de niveles es válido o tolerable.

.. code:: python

    # %load ../data/codigo2.py
    from enum import Enum
    
    class State(Enum):
        VALIDO = 1
        TOLERABLE = 2
        INVALIDO = 3
    
    # Niveles de prueba para el problema
    niveles = """
    7 6 4 2 1
    9 7 6 2 1
    1 3 2 4 5
    8 6 4 4 1
    1 3 6 7 9
    1 2 7 8 9
    """
    
    def ascending(nivel):
        for i in range(len(nivel)-1):
            if nivel[i] > nivel[i+1]:
                return False
        return True
    
    def descending(nivel):
        for i in range(len(nivel)-1):
            if nivel[i] < nivel[i+1]:
                return False
        return True
    
    
    def testea_nivel(nivel):
    
        if ascending(nivel):
            return "Ascendente"
        elif descending(nivel):
            return "Descendente"
        else:
            return "ZigZag"
        
    def testea_niveles(niveles):
        return [testea_nivel(nivel) for nivel in niveles]
    
    def remove_one(nivel):
        return [nivel[1:n] + nivel[n+1:len(nivel)] for n in range(0, len(nivel))]
        
    def testea_niveles_menos_uno(niveles2d):
    
        all_status = []
        for nivel in niveles2d:
            print(nivel, testea_nivel(nivel))
            nivel_status = testea_nivel(nivel)
    
            if nivel_status == State.INVALIDO:
                nivel_menos_uno = remove_one(nivel)
                nivel_status = testea_niveles(nivel_menos_uno)
                status = State.TOLERABLE if State.VALIDO in nivel_status else State.INVALIDO
            else:
                status = State.VALIDO
    
            all_status.append(status)
        return all_status 
    
    
    if __name__ == "__main__":
        #
        #   Prueba 
        #
    
        niveles2d = [n.split() for n in niveles.splitlines()[1:-1]]
        niveles2d = [[int(n) for n in nivel] for nivel in niveles2d]
        print(niveles2d)
    
        niveles_menos_uno = remove_one(niveles2d[0])
        testea_niveles_menos_uno(niveles2d)
    
        #
        #   Niveles de archivo
        #
        # Leer archivo niveles.txt
        niveles_from_file = []
        with open("niveles.txt") as f:
            for line in f:
                niveles_from_file.append([int(n) for n in line.split()])
    
        print(niveles_from_file)
    
        status_of_niveles_from_file = testea_niveles_menos_uno(niveles_from_file)
    
        for s in [v.name for v in  status_of_niveles_from_file]:
            print(s)
    
        # Leer los status correctos de status_niveles.txt
        status_correctos = []
        with open("status_niveles.txt") as f:
            for line in f:
                status_correctos.append(line.strip())
    
        # Comparación 
        for sf,sc in zip(status_of_niveles_from_file, status_correctos):
            print(sf.name, sc)
            assert sf == State[sc]
    


El código contiene un conjunto de niveles de ejemplo, sin embargo, no
parece dar los resultados esperados. Por favor:

-  Corrija los errores que encuentre en el código.

-  Escriba comentarios en el código sobre el error que encontró y cómo
   lo resolvió.

-  Escriba los *docstrings* y otros comentarios pertinentes que
   **mejoren** la lectura del código.

Nuestro cliente nos ha provisto de un archivo de niveles
``<niveles.txt>``, y sus correspondientes status (válido, inválido o
tolerable) en el archivo ``<status_niveles.txt>``.

-  Verifique que las correcciones realizadas con estos datos.
